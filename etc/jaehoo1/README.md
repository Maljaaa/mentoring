# ETC

## 블락 논블락/싱크 어싱크

### 블럭 / 논블럭
함수 호출에 대한 이야기. 기술적으로 명확히 구분된다.  
  
**Block**
* 함수 A를 호출했을 때, 함수 A의 수행이 모두 끝날 때 까지 기다린다(Block)
* 함수 A의 수행이 모두 끝나고 리턴되면, 함수 A를 호출한 부분의 다음 부분부터 이어서 실행한다.
* 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않으면 Block이다.

**Non-Block**
* 함수 A를 호출했을 때, 함수 A의 실행을 요청하고 바로 리턴된다(Non-Block).
* 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 하면 Non-Block이다.

### 동기 / 비동기
행위에 대한 이야기. 기술적으로는 구분되지 않지만 추상적으로 구분한다.  
  
작업A와 작업B가 있다고 함  
**Synchronous**
* 작업A가 먼저 모두 처리되고 나서 작업 B가 처리되기 시작하면(하나씩 순차적으로 처리되면) 동기이다.
* 작업A가 작업B를 관찰하는 작업이라면, 작업A와 작업B가 동시에 처리되더라도 동기이다. (여기서 작업A와 작업B를 서로 바꾸어 생각해도 똑같다.)
* 호출된 함수의 수행 결과 및 종료를 호출된 함수 뿐 아니라 호출한 함수도 함께 신경쓰면 동기이다.

**Asynchoronous**
* 작업A와 작업B가 동시에 처리되면 비동기이다.
* 작업A와 작업B는 인과관계가 있어야 한다.
* 작업A와 작업B가 인과관계가 없으면, 동시에 처리되더라도 비동기라고 볼 수 없다.
* 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경쓰고 처리하면 비동기이다.

### 조합
**블럭 & 동기**  
![image](https://user-images.githubusercontent.com/44667299/163563806-c9df9aed-9019-4364-9aac-addb9ed0c625.png)  
A가 실행되다가 B라는 일을 수행하는 함수를 호출해서 B를 시작한다. B라는 일이 끝나면 함수를 리턴한다. A와 B는 순차적으로 진행되기 때문에 동기이며,  B라는 일을 하는 함수를 호출하고 그 일이 끝나고 나서야 리턴되므로 블럭된 것이다. 따라서 블럭/동기
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는 중  
>손님 : (그 자리에 서서 기다리는 중. 결과가 궁금함. 테이블 못가고 서있음.)

<br/>

**블럭 & 비동기**  
![image](https://user-images.githubusercontent.com/44667299/163564201-001675ce-4280-4e0e-8d1d-f7069f3c77af.png)  
A는 B라는 일을 시킨다. 그리고 바로 리턴하고 (여기서는 논블럭)  B는 일을 시작하고, A도 자신의 일을 한다. A는 중간에 B라는 일이 하는 중간 결과를 보고 받아서 처리해야한다. A는 B에게 요청을 해서 중간결과를 기다린다(블록), 요청의 결과를 받고 나서 그 결과를 이용해서 A는 자신의 일을 처리한다. 동시에 B 는 또 자신의 일을 동시에 한다. (비동기) A는 다시 B에게 중간결과를 요청해서 기다린다 (블록) , 요청의 결과를 받고 A는 자신의 일을, B는 자신의 일을 한다. 반복된다.  
  
이 글을 읽고, 사실 갸우뚱 해야한다. 중간에 블록되는 동안에는 "동기" 라고 말할 수 있기 때문이다. 즉 어느 한 순간에 대해 해석하자면 틀릴 수도 있는 것이다. "정답"이 존재하지 않는다. 다만 이런 패턴들이 분명히 사용되고 있구나라고 감을 잡는게 목적이다.  
  
블럭 & 비동기는 결국 다른 작업이 끝날 때를 기다려야 하기 때문에 동기 & 비동기와 비슷한 효율이 나온다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는중  
>손님 : (안궁금함. 테이블에 가고싶지만 못가고 서있음.)

<br/>

**논블럭 & 동기**  
![image](https://user-images.githubusercontent.com/44667299/163564556-a463f3ac-de02-431a-95aa-88ccea5ad7f3.png)  
A는 B라는 일을 시킨다. 바로 리턴한다. (논블럭) B는 일을 시작하는데, A는 자신의 일을 하지 않는다. A의 하는 일이란 그저 B가 하는 일을 확인하는 것이다. B가 결과 보고(중간 보고가 아니다) 를 했는지를 확인하는 함수를 호출하고, 바로 리턴한다 (논블럭) 즉 결과 보고를 받을 때 까지 기다리는게 아니라, 결과 보고가 나왔는지 확인하고 바로 리턴하는 것이다. 이 짓을 계속한다. 즉 함수를 계속 논블럭으로 호출되긴 하나, A는 그저 B를 염탐할 뿐이다. 이 상태를 말한다. 그냥 염탐하지 말고 B가 일을 모두 끝마치고 리턴되길 기다리지(그냥 블럭/동기로 하는게 나은 상황이 연출된다)  
  
이후에 B가 결과보고를 하면, B는 자신의 일이 끝난 것이고 A는 이제서야 자신의 일을 처리하게 된다. 즉 순차적이라는 말이다. 따라서 동기  
  
논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 즉, 호출된 함수가 호출한 함수에게 제어권을 바로 return하여 호출한 함수가 다른 업무를 볼 수 있었음(Non-Blocked)에도 불구하고, 여전히 호출된 함수의 업무 결과에만 계속 함께 신경쓰느라(Synchronous) 제 할일을 못하게 되는 현상이 일어난다. 논블럭 & 동기도 효율이 좋지 않다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는중  
>손님 : 재촉

<br/>

**논블럭 & 비동기**  
![image](https://user-images.githubusercontent.com/44667299/163565103-59e46cb6-9f78-4626-95eb-41cc4cad0778.png)  
A는 B의 일을 시작시키고 바로 리턴한다. (논블럭) 그리고 A와B는 각자 자신의 일을 한다. (비동기)  
  
자원이 충분하다면 효율이 좋다. 자신의 작업이 멈추지도 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는 중  
>손님 : 자리가서 SNS, 유튜브 시청  
>직원 : 아메리카노 제작 완료

<br/>

출처 : https://hamait.tistory.com/930  
사진 출처 : https://velog.io/@leehyunho2001/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD

### 결론
정답은 없다.  
  
1 구분하지 않는다.  
  
블럭/동기는 같이 말하며, 논블럭/비동기도 함께 묶어 말한다.  
애초에 구분할 필요가 없다.  

<br/>

2 굳이 구분할 경우  
  
블럭/논블럭은 동시성과는 무관한 이야기이다. 단지 메서드 호출한 후로 시간이 오래 걸리면 블로킹이다. 즉 메서드가 얼마나 오래 걸리냐의 문제로 블록과 논블록은 귀결된다.

## WebServer VS WebApplicationServer

### WebServer
웹 브라우저의 요청을 받아 HTTP를 통해 웹 브라우저에서 요청하는 HTML 문서나 오브젝트(이미지 파일 등)를 전송해주는 서버  
>예 : Apache HTTP Server, Microsoft Internet Information Service, Google Web Server 등

### WebApplicationServer
사용자에게 동적 서비스를 제공하기 위해 웹 서버로부터 요청을 받아 데이터 처리를 수행하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행하는 서버
>예 : Oracle WebLogic, Apache Tomcat, IBM WebSphere, JEUS 등

### WebServer가 필요한 이유?
* 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정
  * 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
  * 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
  * Web Server를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
* 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.

### WAS가 필요한 이유?
* 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재
  * 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
  * 이때, WebServer만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고(정적 컨텐츠) 서비스를 해야 한다.
  * 하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
* 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.

### 그렇다면 WAS가 Web Server의 기능도 모두 수행하면 되지 않을까? X
* 기능을 분리하여 서버 부하 방지
  * WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 WebServer에서 빠르게 클라이언트에 제공하는 것이 좋다.
  * WAS는 기본적으로 동적 컨텐츠를 제공하기 위해 존재하는 서버이다.
  * 만약 정적 컨텐츠 요청까지 WAS가 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다.
  * 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다.
* 물리적으로 분리하여 보안 강화
  * SSL에 대한 암복호화 처리에 WebServer를 사용
* 여러 대의 WAS를 연결 가능
  * Load Balancing을 위해서 WebServer를 사용
  * fail over(장애 극복), fail back 처리에 유리
  * 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) WebServer와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
  * 예를 들어, 앞 단의 WebServer에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다.
* 여러 웹 어플리케이션 서비스 가능
  * 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우
* 기타
  * 접근 허용 IP 관리, 2대 이상의 서버에서의 세션 관리 등도 WebServer에서 처리하면 효율적이다.

즉, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.  
WebServer를 WAS 앞에 두고 필요한 WAS들을 WebServer에 플러그인 형태로 설정하면 더욱 효율적인 분산 처리가 가능하다.

>failover : 시스템, 서버, 네트워크가 이상이 생겼을 경우 예비시스템으로 전환되는 기능  
>failback : failover에 따라 전환된 서버/시스템/네트워크를 장애 발생전으로 되돌리는 처리

## Monolithic service Application VS Micro Service Application
## Multi Module VS MSA
## NginX VS Apache
## Servlet VS Netty
## 로드밸런싱
## Reverse Proxy
## CDN
## 캐시
## E-TAG
## 성능 테스트
### Virtual User
### TPS(RPS)
### MAU/DAU
# 기술
## 로깅 라이브러리 비교(스프링/자바 -> 보안 이슈 적지 말아라)
## RabbitMq
## ActiveMq
## 카프카
## ELK(elasticStack)
## 레디스
## 도커
## 쿠버네티스
## 프로메테우스
## 그라파나 
## 코틀린 

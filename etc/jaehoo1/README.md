# ETC

## 블락 논블락/싱크 어싱크

### 블럭 / 논블럭
함수 호출에 대한 이야기. 기술적으로 명확히 구분된다.  
  
**Block**
* 함수 A를 호출했을 때, 함수 A의 수행이 모두 끝날 때 까지 기다린다(Block)
* 함수 A의 수행이 모두 끝나고 리턴되면, 함수 A를 호출한 부분의 다음 부분부터 이어서 실행한다.
* 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return하지 않으면 Block이다.

**Non-Block**
* 함수 A를 호출했을 때, 함수 A의 실행을 요청하고 바로 리턴된다(Non-Block).
* 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 하면 Non-Block이다.

### 동기 / 비동기
행위에 대한 이야기. 기술적으로는 구분되지 않지만 추상적으로 구분한다.  
  
작업A와 작업B가 있다고 함  
**Synchronous**
* 작업A가 먼저 모두 처리되고 나서 작업 B가 처리되기 시작하면(하나씩 순차적으로 처리되면) 동기이다.
* 작업A가 작업B를 관찰하는 작업이라면, 작업A와 작업B가 동시에 처리되더라도 동기이다. (여기서 작업A와 작업B를 서로 바꾸어 생각해도 똑같다.)
* 호출된 함수의 수행 결과 및 종료를 호출된 함수 뿐 아니라 호출한 함수도 함께 신경쓰면 동기이다.

**Asynchoronous**
* 작업A와 작업B가 동시에 처리되면 비동기이다.
* 작업A와 작업B는 인과관계가 있어야 한다.
* 작업A와 작업B가 인과관계가 없으면, 동시에 처리되더라도 비동기라고 볼 수 없다.
* 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경쓰고 처리하면 비동기이다.

### 조합
**블럭 & 동기**  
![image](https://user-images.githubusercontent.com/44667299/163563806-c9df9aed-9019-4364-9aac-addb9ed0c625.png)  
A가 실행되다가 B라는 일을 수행하는 함수를 호출해서 B를 시작한다. B라는 일이 끝나면 함수를 리턴한다. A와 B는 순차적으로 진행되기 때문에 동기이며,  B라는 일을 하는 함수를 호출하고 그 일이 끝나고 나서야 리턴되므로 블럭된 것이다. 따라서 블럭/동기
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는 중  
>손님 : (그 자리에 서서 기다리는 중. 결과가 궁금함. 테이블 못가고 서있음.)

<br/>

**블럭 & 비동기**  
![image](https://user-images.githubusercontent.com/44667299/163564201-001675ce-4280-4e0e-8d1d-f7069f3c77af.png)  
A는 B라는 일을 시킨다. 그리고 바로 리턴하고 (여기서는 논블럭)  B는 일을 시작하고, A도 자신의 일을 한다. A는 중간에 B라는 일이 하는 중간 결과를 보고 받아서 처리해야한다. A는 B에게 요청을 해서 중간결과를 기다린다(블록), 요청의 결과를 받고 나서 그 결과를 이용해서 A는 자신의 일을 처리한다. 동시에 B 는 또 자신의 일을 동시에 한다. (비동기) A는 다시 B에게 중간결과를 요청해서 기다린다 (블록) , 요청의 결과를 받고 A는 자신의 일을, B는 자신의 일을 한다. 반복된다.  
  
이 글을 읽고, 사실 갸우뚱 해야한다. 중간에 블록되는 동안에는 "동기" 라고 말할 수 있기 때문이다. 즉 어느 한 순간에 대해 해석하자면 틀릴 수도 있는 것이다. "정답"이 존재하지 않는다. 다만 이런 패턴들이 분명히 사용되고 있구나라고 감을 잡는게 목적이다.  
  
블럭 & 비동기는 결국 다른 작업이 끝날 때를 기다려야 하기 때문에 동기 & 비동기와 비슷한 효율이 나온다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는중  
>손님 : (안궁금함. 테이블에 가고싶지만 못가고 서있음.)

<br/>

**논블럭 & 동기**  
![image](https://user-images.githubusercontent.com/44667299/163564556-a463f3ac-de02-431a-95aa-88ccea5ad7f3.png)  
A는 B라는 일을 시킨다. 바로 리턴한다. (논블럭) B는 일을 시작하는데, A는 자신의 일을 하지 않는다. A의 하는 일이란 그저 B가 하는 일을 확인하는 것이다. B가 결과 보고(중간 보고가 아니다) 를 했는지를 확인하는 함수를 호출하고, 바로 리턴한다 (논블럭) 즉 결과 보고를 받을 때 까지 기다리는게 아니라, 결과 보고가 나왔는지 확인하고 바로 리턴하는 것이다. 이 짓을 계속한다. 즉 함수를 계속 논블럭으로 호출되긴 하나, A는 그저 B를 염탐할 뿐이다. 이 상태를 말한다. 그냥 염탐하지 말고 B가 일을 모두 끝마치고 리턴되길 기다리지(그냥 블럭/동기로 하는게 나은 상황이 연출된다)  
  
이후에 B가 결과보고를 하면, B는 자신의 일이 끝난 것이고 A는 이제서야 자신의 일을 처리하게 된다. 즉 순차적이라는 말이다. 따라서 동기  
  
논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 즉, 호출된 함수가 호출한 함수에게 제어권을 바로 return하여 호출한 함수가 다른 업무를 볼 수 있었음(Non-Blocked)에도 불구하고, 여전히 호출된 함수의 업무 결과에만 계속 함께 신경쓰느라(Synchronous) 제 할일을 못하게 되는 현상이 일어난다. 논블럭 & 동기도 효율이 좋지 않다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는중  
>손님 : 재촉

<br/>

**논블럭 & 비동기**  
![image](https://user-images.githubusercontent.com/44667299/163565103-59e46cb6-9f78-4626-95eb-41cc4cad0778.png)  
A는 B의 일을 시작시키고 바로 리턴한다. (논블럭) 그리고 A와B는 각자 자신의 일을 한다. (비동기)  
  
자원이 충분하다면 효율이 좋다. 자신의 작업이 멈추지도 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다.
>손님 : 아메리카노 주문  
>직원 : 아메리카노 만드는 중  
>손님 : 자리가서 SNS, 유튜브 시청  
>직원 : 아메리카노 제작 완료

<br/>

출처 : https://hamait.tistory.com/930  
사진 출처 : https://velog.io/@leehyunho2001/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%9F%AD-%EB%84%8C%EB%B8%94%EB%9F%AD

### 결론
정답은 없다.  
  
1 구분하지 않는다.  
  
블럭/동기는 같이 말하며, 논블럭/비동기도 함께 묶어 말한다.  
애초에 구분할 필요가 없다.  

<br/>

2 굳이 구분할 경우  
  
블럭/논블럭은 동시성과는 무관한 이야기이다. 단지 메서드 호출한 후로 시간이 오래 걸리면 블로킹이다. 즉 메서드가 얼마나 오래 걸리냐의 문제로 블록과 논블록은 귀결된다.

## WebServer VS WebApplicationServer 
## Monolithic service Application VS Micro Service Application
## Multi Module VS MSA
## NginX VS Apache
## Servlet VS Netty
## 로드밸런싱
## Reverse Proxy
## CDN
## 캐시
## E-TAG
## 성능 테스트
### Virtual User
### TPS(RPS)
### MAU/DAU
# 기술
## 로깅 라이브러리 비교(스프링/자바 -> 보안 이슈 적지 말아라)
## RabbitMq
## ActiveMq
## 카프카
## ELK(elasticStack)
## 레디스
## 도커
## 쿠버네티스
## 프로메테우스
## 그라파나 
## 코틀린 

# 제네릭 사용법
* 제네릭(generic) : 데이터 타입을 일반화한다는 것을 의미
* 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

[ 장점 ]
1. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있음
2. 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있음

[ 선언 ]
```java
class MyArray<T> {
  T element;
  void setElement(T element) {
    this.element = element;
  }
  T getElement() {
    return element;
  }
}
```
> 여러 개의 타입 변수는 쉼표(,)로 구분

* \<T> : Type
* \<E> : Element
* \<K> : Key
* \<N> : Number
* \<V> : Value
* \<R> : Result


[ 생성 ]
  
```java
MyArray<Integer> myArr = new MyArray<Integer>();
```
> 타입 변수 자리에 기본 타입 x, 래퍼(wrapper) 클래스를 사용해야 함

[ 제거 ]
* 컴파일 -> 컴파일러에 의해 자동으로 검사되어 타입 변환됨
* 모든 제네릭 타입 제거됨 -> 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함 x

# 제네릭 주요 개념 (바운디드 타입, 와일드 카드)
## 바운디드 타입
* 제네릭으로 사용되는 파라미터 타입을 제한할 수 있는 것

```java
public class Person<T extends Number> {...}
public interface Person<T extends Number> {...}
```
> extends하고 타입을 제한한다
>
> 위와 같이 제네릭의 파라미터를 정의한 경우, Number의 하위 클래스가 아닌 클래스는 타입 파라미터로 적용되는 것이 불가능

* Comparable 인터페이스를 구현하면 compareTo() 메소드를 오버라이딩 -> 제한된 타입끼리만 비교 가능

## 와일드 카드
* 제네릭으로 사용되는 파라미터 타입을 제한할 수 있는 것

* <? extends T> : 와일드 카드의 상위 타입을 제한 -> T의 하위 타입 클래스만 사용 가능
* <? super T> : 와일드 카드의 하위 타입을 제한 -> T의 상위 타입 클래스만 사용 가능
* <?> : 모든 타입이 가능

```java
import java.util.*;

class LandAnimal { public void crying() { System.out.println("육지동물"); } }
class Cat extends LandAnimal { public void crying() { System.out.println("냐옹냐옹"); } }
class Dog extends LandAnimal { public void crying() { System.out.println("멍멍"); } }
class Sparrow { public void crying() { System.out.println("짹짹"); } }

class AnimalList<T> {
    ArrayList<T> al = new ArrayList<T>();

    public static void cryingAnimalList(AnimalList<? extends LandAnimal> al) {
        LandAnimal la = al.get(0);
        la.crying();
    }
    
    void add(T animal) { al.add(animal); }
    T get(int index) { return al.get(index); }
    boolean remove(T animal) { return al.remove(animal); }
    int size() { return al.size(); }
}

public class Generic03 {
    public static void main(String[] args) {
        AnimalList<Cat> catList = new AnimalList<Cat>();
        catList.add(new Cat());
        AnimalList<Dog> dogList = new AnimalList<Dog>();
        dogList.add(new Dog());
        
        AnimalList.cryingAnimalList(catList);
        AnimalList.cryingAnimalList(dogList);
    }
}
```

# 제네릭 메소드 만들기
* 제네릭 메소드(generic method) : 선언부에 타입 변수를 사용한 메소드

```java
pulic static <T> void ex(...){
  ...
}
```

# Erasure(소거)
* 타입 파라미터를 컴파일 타임에만 검사하고, 런타임 시에는 해당 타입 정보를 알 수 없게 하는 것

* unbounded Type(<?>, <T>) -> Object
* bound type(<E extends Comparable>) -> Comparable
* 제네릭 타입을 사용할 수 있는 일반 클래스, 인터페이스, 메소드에만 Erasure 적용

```java
// 컴파일 할 때(타입 소거 전)
public vlass Test<T> {
  public void test(T test) {
    System.out.println(test.toString());
  }
}

// 런타임 때(타입 소거 후)
public class Test {
  public void test(Object test) {
    System.out.println(test.toString());
  }
}
```

# 공변성, 반공변성, 무공변성
## 공변성
* 자기 자신과 자식 객체로 타입 변환을 허용

```java
Object[] before = new Long[1};
```

## 불공변
* 두 개의 타입은 전혀 관련이 없음

```java
public class Test {
  public static void test(List<Object> list) {
  }
  public static void main(String[] args) {
    List<String> list = new ArrayList<>();
    list.add("abc");
    test(list); // 
```
## 반공변성

# 람다식 사용법
* 메소드를 하나의 식으로 표현한 것

```java
// 최소값 구하기
int min(int x, int y) {
  return x < y ? x : y;
}

// 람다 표현식
(x, y) -> x < y ? x : y;
```

[ 문법 ] 
* ( 매개변수목록 ) -> { 함수몸체 }

[ 유의 사항 ]
1. 매개변수의 타입을 추론할 수 있는 경우 타입 생략 가능
2. 매개변수가 하나인 경우에는 괄호 생략
3. 함수의 몸체가 하나의 명령문만으로 이루어진 경우 -> 중괄호 생략 & 세미콜론 x
4. 함수의 몸체가 하나의 return 문으로만 이루어진 경우에는 중괄호 생략x
5. return문 대신 표현식 사용 가능, 이때 반환값은 표현식의 결과값 & 세미콜론 x

# 함수형 인터페이스
* 함수형인터페이스(Functional Interface) : 람다 표현식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입
* 단 하나의 추상 메소드만을 가져야 함
* 어노테이션을 사용하여 함수형 인터페이스임을 명시

```java
@FunctionalInterface
interface Calc {  // 함수형 인터페이스 선언
  public int min(int x, int y);
}

pubilc class Lambda02 {
  public static void main(String[] args) {
    Calc minNum = (x, y) -> x < y ? x : y;  // 추상 메서드 구현
    System.out.println(minNum.min(3, 4) // 함수형 인터페이스 사용
  }
}
```
> 실행 결과 : 3

# Variable Capture
* 람다 캡처링(Lambda Capturing) : 외부에서 정의된 변수인 자유 변수를 참조하는 것

[ 제약 조건 ]
1. 자유 변수는 final로 선언되어 있어야 함(java 8 이전)
2. final로 선언되지 않은 자유 변수는 final처럼 동작해야 함(effectively final)

[ final 또는 effectively final 이어야 하는 이유 ]
* 지역변수는 JVM 영역중 stack(스레드끼리 공유 x)영역에 생성
* 인스턴스 변수는 JVM 영역중 heap(스레드끼리 공유o)영역에 생성
* 지역 변수(자유 변수)가 있는 스레드가 사라진다면? -> 변수를 참조하고 있다면 오류 발생
* 람다에서는 자유 변수 참조 가능
* => variable capture 때문에 가능!!
* 자유 변수를 참조할 때 직접 그 변수를 참조하는 것이 아니라
* 자유 변수를 자신의 stack에 복사하여 참조
* 그렇기 때문에 variable capture가 될 자유 변수는 수정이 불가능하도록 final이거나 final처럼 동작해야 함
* java8 이후로 final을 붙히지 않아도 effectively final로 선언

# 메소드, 생성자 레퍼런스(메서드 참조)
## 메소드 참조(method reference) 
* 메소드 참조 : 불필요한 매개변수를 제거하고 사용할 수 있도록 해줌

```java
클래스이름 :: 메소드이름
또는
참조변수이름 :: 메소드이름
```

* 클래스 메소드 호출 예제
```java
(base, exponent) -> Math.pow(base, exponent);
```

* 메소드 참조 예제
```java
Math::pow();
```

* 람다 표현식 vs 메소드 참조
```java
DoubleUnaryOperator oper;

oper = (n) -> Math.abs(n);  // 람다 표현식
System.out.println(oper.applyAsDouble(-5));

oper = Math::abs; // 메소드 참조
System.out.println(oper.applyAsDouble(-5));
```
> 실행 결과 : 5.0 5.0

## 생성자 참조
* 생성자 참조 : 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환 가능

* 단순 람다 표현식 예제
```java
(a) -> {return new Object(a);}
```

* 

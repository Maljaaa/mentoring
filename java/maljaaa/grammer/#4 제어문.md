# ëª©í‘œ
ìë°”ê°€ ì œê³µí•˜ëŠ” ì œì–´ë¬¸ì„ í•™ìŠµí•˜ì„¸ìš”.

# í•™ìŠµí•  ê²ƒ (í•„ìˆ˜)
## ì¡°ê±´ë¬¸
* ifë¬¸, if elseë¬¸, switch caseë¬¸

## ë°˜ë³µë¬¸
* forë¬¸, whileë¬¸, for eachë¬¸

### for each
* J2SE 5.0(Java Platform, Standard Edition, java ê°œë°œ/ì‹¤í–‰ í™˜ê²½)ë¶€í„° ì¶”ê°€ë¨

```
for(type var: iterate) {
  body-of-loop
}
```

* iterate : ë£¨í”„ë¥¼ ëŒë¦´ ê°ì²´ -> ë£¨í”„ë¥¼ ëŒë¦´ ìˆ˜ ìˆëŠ” í˜•íƒœì¸ **ë°°ì—´ or ArrayList** ë“±
* iterate ê°ì²´ì—ì„œ í•œ ê°œì”© ìˆœì°¨ì ìœ¼ë¡œ varì— ëŒ€ì…ë˜ì–´ forë¬¸ ìˆ˜í–‰

# ê³¼ì œ (ìë£Œêµ¬ì¡°)
# ê³¼ì œ 0. JUnit 5 í•™ìŠµí•˜ì„¸ìš”.

```
ì¸í…”ë¦¬J, ì´í´ë¦½ìŠ¤, VS Codeì—ì„œ JUnit 5ë¡œ í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±í•˜ëŠ” ë°©ë²•ì— ìµìˆ™í•´ ì§ˆ ê²ƒ.
ì´ë¯¸ JUnit ì•Œê³  ê³„ì‹ ë¶„ë“¤ì€ ë‹¤ë¥¸ ê²ƒ ì•„ë¬´ê±°ë‚˜!
```

* ì˜ˆì œ í”„ë¡œì íŠ¸ ìƒì„±
![28](https://user-images.githubusercontent.com/61977260/189817278-3be7fb36-20f6-4dbe-92ac-cdc10ab70b2a.png)

* Main.java ìƒì„±
![27](https://user-images.githubusercontent.com/61977260/189817414-8ca31d4e-c088-4f82-9199-61f4065e0eac.png)


* Multiplier.java ìƒì„±
![26](https://user-images.githubusercontent.com/61977260/189855147-d0226d35-b2f5-4c2c-894c-f12b112e8f4d.png)

* test ê²½ë¡œ ìƒì„±
![24](https://user-images.githubusercontent.com/61977260/189855252-77bf22b0-ea92-4af4-b59b-2c91fbabd004.png)

* í…ŒìŠ¤íŠ¸ íŒŒì¼ë¡œ ì„¤ì •
![21](https://user-images.githubusercontent.com/61977260/189855704-da9799b1-86a9-45fd-8145-59c64fc51267.png)

* ì „ í›„ ë¹„êµ

ğŸŒ± ì „

![22](https://user-images.githubusercontent.com/61977260/189855807-ea581b0f-eadd-433d-9297-f664f760bc1d.png)

ğŸŒ± í›„

![14](https://user-images.githubusercontent.com/61977260/189855849-fd617185-7bc2-4836-bc8f-78a43ba57afe.png)

* í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
![20](https://user-images.githubusercontent.com/61977260/189856147-4f49cbe7-138a-45da-8790-98c4091f4e78.png)
![19](https://user-images.githubusercontent.com/61977260/189856174-4a41b771-a715-47c5-967b-2b8801b30748.png)

* JUnit 5 ì„¤ì • ë° ìƒì„±
![18](https://user-images.githubusercontent.com/61977260/189856297-659059fb-7a63-4069-995c-b24df8efc541.png)

* í…ŒìŠ¤íŠ¸ ë©”ì„œë“œ ì„¤ì • ë° ì ìš©
![16](https://user-images.githubusercontent.com/61977260/189856412-141559ec-ba28-4a06-8f38-d0326780d428.png)

* ìƒì„± í›„ ì²« í™”ë©´
![15](https://user-images.githubusercontent.com/61977260/189856487-ac3938ba-eaeb-4760-b07f-25027fa32188.png)

* ì½”ë“œ ì‘ì„± í›„ ì‹¤í–‰
![13](https://user-images.githubusercontent.com/61977260/189856590-49ffeaeb-4c07-4119-9da1-fa67d3a5742e.png)

* ì‹¤í–‰ ê²°ê³¼(ì—ëŸ¬)
![12](https://user-images.githubusercontent.com/61977260/189856671-56be53de-3d7c-45d8-8792-f4b0a5320845.png)

* ì‹¤í–‰ ê²°ê³¼(ì„±ê³µ)
![11](https://user-images.githubusercontent.com/61977260/189856719-260f3eb6-aa03-4204-83fe-d870e9adebbe.png)

# ê³¼ì œ 1. live-study ëŒ€ì‹œ ë³´ë“œë¥¼ ë§Œë“œëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
ê¹ƒí—™ ì´ìŠˆ 1ë²ˆë¶€í„° 18ë²ˆê¹Œì§€ ëŒ“ê¸€ì„ ìˆœíšŒí•˜ë©° ëŒ“ê¸€ì„ ë‚¨ê¸´ ì‚¬ìš©ìë¥¼ ì²´í¬ í•  ê²ƒ.
ì°¸ì—¬ìœ¨ì„ ê³„ì‚°í•˜ì„¸ìš”. ì´ 18íšŒì— ì¤‘ì— ëª‡ %ë¥¼ ì°¸ì—¬í–ˆëŠ”ì§€ ì†Œìˆ«ì  ë‘ìë¦¬ê°€ì§€ ë³´ì—¬ì¤„ ê²ƒ.
Github ìë°” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ í¸ë¦¬í•©ë‹ˆë‹¤.
ê¹ƒí—™ APIë¥¼ ìµëª…ìœ¼ë¡œ í˜¸ì¶œí•˜ëŠ”ë° ì œí•œì´ ìˆê¸° ë•Œë¬¸ì— ë³¸ì¸ì˜ ê¹ƒí—™ í”„ë¡œì íŠ¸ì— ì´ìŠˆë¥¼ ë§Œë“¤ê³  í…ŒìŠ¤íŠ¸ë¥¼ í•˜ì‹œë©´ ë” ìì£¼ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# ê³¼ì œ 2. LinkedListë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
```
LinkedListì— ëŒ€í•´ ê³µë¶€í•˜ì„¸ìš”.
ì •ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ListNode í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
ListNode add(ListNode head, ListNode nodeToAdd, int position)ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
ListNode remove(ListNode head, int positionToRemove)ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
boolean contains(ListNode head, ListNode nodeTocheck)ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
```

## LinkedList
ğŸš€ ë°°ì—´ì„ ë¬¼ì–´ë¬¼ì–´ ì°¾ì•„ê°€ëŠ” ë°©ì‹

**[ êµ¬ì¡° ]**
![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2939.png)

```
class ListNode{
    public Object data;
    public ListNode next;

    public ListNode(Object input){
        this.data = input;
        this.next = null;
    }

    public ListNode(Object input, ListNode next){
        this.data = data;
        this.next = next;
    }

    public String toString(){
        return String.valueOf(this.data);
    }
}

public class LinkedList {
    private ListNode head;
    private int size;

    public LinkedList(){
        this.head = null;
        size = 0;
    }

    ListNode add(ListNode head, ListNode nodeToAdd, int position){
        ListNode newNode = head;

        // addí•  ìˆ˜ ì—†ëŠ” ê²½ìš°
        if(size < position){
            return null;
        }

        if(head == null){
            newNode = nodeToAdd;
            head = newNode;
        } else{
            for(int i = 1; i < position; i++){
                newNode = newNode.next;
            }
            nodeToAdd.next = newNode.next;
            newNode.next = nodeToAdd;
        }

        size++;

        return head;
    }

    ListNode remove(ListNode head, int positionToRemove){
        ListNode newNode = head;

        // removeí•  ìˆ˜ ì—†ëŠ” ê²½ìš°
        if(size <= positionToRemove || head == null){
            return head;
        }

        if(positionToRemove == 0){
            newNode = newNode.next;
            head = newNode;
        } else{
            for(int i = 1; i < positionToRemove; i++){
                newNode = newNode.next;
            }
            newNode.next = newNode.next.next;
        }

        size--;

        return head;
    }

    boolean contains(ListNode head, ListNode nodeTocheck){
        ListNode node = head;
        boolean check = false;

        if(head == null){
            return false;
        }

        while(node != null){
            if(node.data == nodeTocheck.data){
                check = true;
                break;
            }
            node = node.next;
        }

        return check;
    }
}
```

# ê³¼ì œ 3. Stackì„ êµ¬í˜„í•˜ì„¸ìš”.
```
int ë°°ì—´ì„ ì‚¬ìš©í•´ì„œ ì •ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” Stackì„ êµ¬í˜„í•˜ì„¸ìš”.
void push(int data)ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
int pop()ì„ êµ¬í˜„í•˜ì„¸ìš”.
```

```
public class Stack {
    private int array[];
    private int top;
    private int size;

    public Stack(int size){
        this.size = size;
        this.array = new int[size];
        this.top = -1;  // ë°”ë‹¥ë¶€í„° ì‹œì‘
    }

    // ê°’ ë„£ê¸°
    void push(int data){
        if(top == size - 1){
            throw new RuntimeException("out of index");
        }
        array[++top] = data;    // top ë¨¼ì € ì˜¬ë¦¬ê³  ê°’ì„ ë„£ì–´ì•¼ í•¨
    }

    // ê°’ ë¹¼ê¸°
    int pop(){
        if(top == -1){
            throw new RuntimeException("out of index");
        }
        return array[top--];    // data ê´€ê³„ì—†ì´ topì„ ì¤„ì—¬ì„œ ë‚ ë¦¼
    }
}
```

# ê³¼ì œ 4. ì•ì„œ ë§Œë“  ListNodeë¥¼ ì‚¬ìš©í•´ì„œ Stackì„ êµ¬í˜„í•˜ì„¸ìš”.

```
ListNode headë¥¼ ê°€ì§€ê³  ìˆëŠ” ListNodeStack í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
void push(int data)ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
int pop()ì„ êµ¬í˜„í•˜ì„¸ìš”.
```

```
public class ListNodeStack {
    private ListNode head;

    public ListNodeStack(){
        this.head = null;
    }

    void push(int data){
        ListNode newNode = new ListNode(data);
        if(head == null){
            head = newNode;
            return;
        }
        ListNode node = head;
        while(node.next != null){
            node = node.next;
        }
        node.next = newNode;
    }

    Object pop(){
        if(head == null){
            throw new RuntimeException("out of index");
        }
        ListNode before = null;
        ListNode node = head;
        while(node.next != null){
            before = node;
            node = node.next;
        }
        Object data = node.data;
        if(before == null){
            head = null;
        } else{
            before.next = null;
        }
        return data;
    }
}

```

# ê³¼ì œ 5. Queueë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

```
ë°°ì—´ì„ ì‚¬ìš©í•´ì„œ í•œë²ˆ
ListNodeë¥¼ ì‚¬ìš©í•´ì„œ í•œë²ˆ.
```

```
// ë°°ì—´ ì‚¬ìš©
public class Queue {
    private Integer[] array;
    private int front;
    private int back;
    private int size;

    public Queue(int size){
        this.size = size;
        this.array = new Integer[size];
        this.front = -1;
        this.back = -1;
    }

    void push(int data){
        try{
            back++;
            array[back] = data;
            if(front == -1)
                front = back;
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }
    }

    int pop(){
        try{

        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }

        return array[front++];
    }
}

```

```
public class ListNodeQueue {
    private ListNode head;

    public ListNodeQueue(){
        this.head = null;
    }

    void push(int data){
        ListNode newNode = new ListNode(data);
        if(head == null){
            head = newNode;
            return;
        }
        ListNode node = head;
        while(node.next != null){
            node = node.next;
        }
        node.next = newNode;
    }

    Object pop(){
        try{

        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }

        Object data = head.data;
        head = head.next;
        return data;
    }
}

```

# ê³¼ì œ 6. Treeë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

```
int ê°’ì„ ê°€ì§€ê³  ìˆëŠ” ì´ì§„ íŠ¸ë¦¬ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Node ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ì„¸ìš”.
int value, Node left, rightë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
BinrayTreeë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ê³  ì£¼ì–´ì§„ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¶œë ¥í•˜ëŠ” bfs(Node node)ì™€ dfs(Node node) ë©”ì†Œë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
DFSëŠ” ì™¼ìª½, ë£¨íŠ¸, ì˜¤ë¥¸ìª½ ìˆœìœ¼ë¡œ ìˆœíšŒí•˜ì„¸ìš”.
```

```
import java.util.LinkedList;
import java.util.Queue;

class Node{
    int value;
    Node left = null;
    Node right = null;

    public Node(int value){

        this.value = value;
    }
}
public class BinaryTree {
    Node head;

    // ë…¸ë“œ ì¶”ê°€
    void add(Node node){
        Node parent = head;
        Node now = head;
        while(now != null){
            parent = now;
            if(now.value > node.value){ // í° ê°’ ì™¼ìª½, ì‘ì€ ê°’ ì˜¤ë¥¸ìª½
                now = now.left;
            } else{
                now = now.right;
            }
        }

        if(parent == null){
            head = node;
        } else if(parent.value > node.value){
            parent.left = node;
        } else{
            parent.right = node;
        }
    }

    // ë…¸ë“œ ì°¾ê¸°
    boolean find(Node node){
        Node now = head;
        while(now != null){
            if(now.value == node.value){
                return true;
            }
            if(now.value > node.value){
                now = now.left;
            } else{
                now = now.right;
            }
        }
        return false;
    }

    void dfs(Node node){
        if(node == null){
            return;
        }
        System.out.println(node.value);
        dfs(node.left);
        dfs(node.right);
    }

    void bfs(Node node){
        System.out.println("[ DFS ] & [ BFS ]");
        Queue<Node> queue = new LinkedList<>();
        queue.add(node);
        Node now;
        while(!queue.isEmpty()){
            now = queue.poll();
            System.out.println(now.value);
            if(now.left != null){
                queue.add(now.left);
            }
            if(now.right != null){
                queue.add(now.right);
            }
        }
    }

    public static void main(String[] args) {
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);
        Node node6 = new Node(6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.add(node3);
        binaryTree.add(node2);
        binaryTree.add(node1);
        binaryTree.add(node5);
        binaryTree.add(node6);
        binaryTree.add(node4);

        binaryTree.dfs(node3);
        binaryTree.bfs(node3);
    }
}



```

# 목표
자바가 제공하는 제어문을 학습하세요.

# 학습할 것 (필수)
## 조건문
* if문, if else문, switch case문

## 반복문
* for문, while문, for each문

### for each
* J2SE 5.0(Java Platform, Standard Edition, java 개발/실행 환경)부터 추가됨

```
for(type var: iterate) {
  body-of-loop
}
```

* iterate : 루프를 돌릴 객체 -> 루프를 돌릴 수 있는 형태인 **배열 or ArrayList** 등
* iterate 객체에서 한 개씩 순차적으로 var에 대입되어 for문 수행

# 과제 (자료구조)
# 과제 0. JUnit 5 학습하세요.

```
인텔리J, 이클립스, VS Code에서 JUnit 5로 테스트 코드 작성하는 방법에 익숙해 질 것.
이미 JUnit 알고 계신분들은 다른 것 아무거나!
```

* 예제 프로젝트 생성
![28](https://user-images.githubusercontent.com/61977260/189817278-3be7fb36-20f6-4dbe-92ac-cdc10ab70b2a.png)

* Main.java 생성
![27](https://user-images.githubusercontent.com/61977260/189817414-8ca31d4e-c088-4f82-9199-61f4065e0eac.png)


* Multiplier.java 생성
![26](https://user-images.githubusercontent.com/61977260/189855147-d0226d35-b2f5-4c2c-894c-f12b112e8f4d.png)

* test 경로 생성
![24](https://user-images.githubusercontent.com/61977260/189855252-77bf22b0-ea92-4af4-b59b-2c91fbabd004.png)

* 테스트 파일로 설정
![21](https://user-images.githubusercontent.com/61977260/189855704-da9799b1-86a9-45fd-8145-59c64fc51267.png)

* 전 후 비교

🌱 전

![22](https://user-images.githubusercontent.com/61977260/189855807-ea581b0f-eadd-433d-9297-f664f760bc1d.png)

🌱 후

![14](https://user-images.githubusercontent.com/61977260/189855849-fd617185-7bc2-4836-bc8f-78a43ba57afe.png)

* 테스트 파일 생성
![20](https://user-images.githubusercontent.com/61977260/189856147-4f49cbe7-138a-45da-8790-98c4091f4e78.png)
![19](https://user-images.githubusercontent.com/61977260/189856174-4a41b771-a715-47c5-967b-2b8801b30748.png)

* JUnit 5 설정 및 생성
![18](https://user-images.githubusercontent.com/61977260/189856297-659059fb-7a63-4069-995c-b24df8efc541.png)

* 테스트 메서드 설정 및 적용
![16](https://user-images.githubusercontent.com/61977260/189856412-141559ec-ba28-4a06-8f38-d0326780d428.png)

* 생성 후 첫 화면
![15](https://user-images.githubusercontent.com/61977260/189856487-ac3938ba-eaeb-4760-b07f-25027fa32188.png)

* 코드 작성 후 실행
![13](https://user-images.githubusercontent.com/61977260/189856590-49ffeaeb-4c07-4119-9da1-fa67d3a5742e.png)

* 실행 결과(에러)
![12](https://user-images.githubusercontent.com/61977260/189856671-56be53de-3d7c-45d8-8792-f4b0a5320845.png)

* 실행 결과(성공)
![11](https://user-images.githubusercontent.com/61977260/189856719-260f3eb6-aa03-4204-83fe-d870e9adebbe.png)

# 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.
깃헙 이슈 1번부터 18번까지 댓글을 순회하며 댓글을 남긴 사용자를 체크 할 것.
참여율을 계산하세요. 총 18회에 중에 몇 %를 참여했는지 소숫점 두자리가지 보여줄 것.
Github 자바 라이브러리를 사용하면 편리합니다.
깃헙 API를 익명으로 호출하는데 제한이 있기 때문에 본인의 깃헙 프로젝트에 이슈를 만들고 테스트를 하시면 더 자주 테스트할 수 있습니다.

# 과제 2. LinkedList를 구현하세요.
```
LinkedList에 대해 공부하세요.
정수를 저장하는 ListNode 클래스를 구현하세요.
ListNode add(ListNode head, ListNode nodeToAdd, int position)를 구현하세요.
ListNode remove(ListNode head, int positionToRemove)를 구현하세요.
boolean contains(ListNode head, ListNode nodeTocheck)를 구현하세요.
```

## LinkedList
🚀 배열을 물어물어 찾아가는 방식

**[ 구조 ]**
![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2939.png)

```
class ListNode{
    public Object data;
    public ListNode next;

    public ListNode(Object input){
        this.data = input;
        this.next = null;
    }

    public ListNode(Object input, ListNode next){
        this.data = data;
        this.next = next;
    }

    public String toString(){
        return String.valueOf(this.data);
    }
}

public class LinkedList {
    private ListNode head;
    private int size;

    public LinkedList(){
        this.head = null;
        size = 0;
    }

    ListNode add(ListNode head, ListNode nodeToAdd, int position){
        ListNode newNode = head;

        // add할 수 없는 경우
        if(size < position){
            return null;
        }

        if(head == null){
            newNode = nodeToAdd;
            head = newNode;
        } else{
            for(int i = 1; i < position; i++){
                newNode = newNode.next;
            }
            nodeToAdd.next = newNode.next;
            newNode.next = nodeToAdd;
        }

        size++;

        return head;
    }

    ListNode remove(ListNode head, int positionToRemove){
        ListNode newNode = head;

        // remove할 수 없는 경우
        if(size <= positionToRemove || head == null){
            return head;
        }

        if(positionToRemove == 0){
            newNode = newNode.next;
            head = newNode;
        } else{
            for(int i = 1; i < positionToRemove; i++){
                newNode = newNode.next;
            }
            newNode.next = newNode.next.next;
        }

        size--;

        return head;
    }

    boolean contains(ListNode head, ListNode nodeTocheck){
        ListNode node = head;
        boolean check = false;

        if(head == null){
            return false;
        }

        while(node != null){
            if(node.data == nodeTocheck.data){
                check = true;
                break;
            }
            node = node.next;
        }

        return check;
    }
}
```

# 과제 3. Stack을 구현하세요.
```
int 배열을 사용해서 정수를 저장하는 Stack을 구현하세요.
void push(int data)를 구현하세요.
int pop()을 구현하세요.
```

```
public class Stack {
    private int array[];
    private int top;
    private int size;

    public Stack(int size){
        this.size = size;
        this.array = new int[size];
        this.top = -1;  // 바닥부터 시작
    }

    // 값 넣기
    void push(int data){
        if(top == size - 1){
            throw new RuntimeException("out of index");
        }
        array[++top] = data;    // top 먼저 올리고 값을 넣어야 함
    }

    // 값 빼기
    int pop(){
        if(top == -1){
            throw new RuntimeException("out of index");
        }
        return array[top--];    // data 관계없이 top을 줄여서 날림
    }
}
```

# 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.

```
ListNode head를 가지고 있는 ListNodeStack 클래스를 구현하세요.
void push(int data)를 구현하세요.
int pop()을 구현하세요.
```

```
public class ListNodeStack {
    private ListNode head;

    public ListNodeStack(){
        this.head = null;
    }

    void push(int data){
        ListNode newNode = new ListNode(data);
        if(head == null){
            head = newNode;
            return;
        }
        ListNode node = head;
        while(node.next != null){
            node = node.next;
        }
        node.next = newNode;
    }

    Object pop(){
        if(head == null){
            throw new RuntimeException("out of index");
        }
        ListNode before = null;
        ListNode node = head;
        while(node.next != null){
            before = node;
            node = node.next;
        }
        Object data = node.data;
        if(before == null){
            head = null;
        } else{
            before.next = null;
        }
        return data;
    }
}

```

# 과제 5. Queue를 구현하세요.

```
배열을 사용해서 한번
ListNode를 사용해서 한번.
```

```
// 배열 사용
public class Queue {
    private Integer[] array;
    private int front;
    private int back;
    private int size;

    public Queue(int size){
        this.size = size;
        this.array = new Integer[size];
        this.front = -1;
        this.back = -1;
    }

    void push(int data){
        try{
            back++;
            array[back] = data;
            if(front == -1)
                front = back;
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }
    }

    int pop(){
        try{

        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }

        return array[front++];
    }
}

```

```
public class ListNodeQueue {
    private ListNode head;

    public ListNodeQueue(){
        this.head = null;
    }

    void push(int data){
        ListNode newNode = new ListNode(data);
        if(head == null){
            head = newNode;
            return;
        }
        ListNode node = head;
        while(node.next != null){
            node = node.next;
        }
        node.next = newNode;
    }

    Object pop(){
        try{

        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println("out of index");
        }

        Object data = head.data;
        head = head.next;
        return data;
    }
}

```

# 과제 6. Tree를 구현하세요.

```
int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.
int value, Node left, right를 가지고 있어야 합니다.
BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.
DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.
```

```
import java.util.LinkedList;
import java.util.Queue;

class Node{
    int value;
    Node left = null;
    Node right = null;

    public Node(int value){

        this.value = value;
    }
}
public class BinaryTree {
    Node head;

    // 노드 추가
    void add(Node node){
        Node parent = head;
        Node now = head;
        while(now != null){
            parent = now;
            if(now.value > node.value){ // 큰 값 왼쪽, 작은 값 오른쪽
                now = now.left;
            } else{
                now = now.right;
            }
        }

        if(parent == null){
            head = node;
        } else if(parent.value > node.value){
            parent.left = node;
        } else{
            parent.right = node;
        }
    }

    // 노드 찾기
    boolean find(Node node){
        Node now = head;
        while(now != null){
            if(now.value == node.value){
                return true;
            }
            if(now.value > node.value){
                now = now.left;
            } else{
                now = now.right;
            }
        }
        return false;
    }

    void dfs(Node node){
        if(node == null){
            return;
        }
        System.out.println(node.value);
        dfs(node.left);
        dfs(node.right);
    }

    void bfs(Node node){
        System.out.println("[ DFS ] & [ BFS ]");
        Queue<Node> queue = new LinkedList<>();
        queue.add(node);
        Node now;
        while(!queue.isEmpty()){
            now = queue.poll();
            System.out.println(now.value);
            if(now.left != null){
                queue.add(now.left);
            }
            if(now.right != null){
                queue.add(now.right);
            }
        }
    }

    public static void main(String[] args) {
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);
        Node node6 = new Node(6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.add(node3);
        binaryTree.add(node2);
        binaryTree.add(node1);
        binaryTree.add(node5);
        binaryTree.add(node6);
        binaryTree.add(node4);

        binaryTree.dfs(node3);
        binaryTree.bfs(node3);
    }
}



```

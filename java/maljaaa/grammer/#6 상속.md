# 자바 상속의 특징
![image](https://user-images.githubusercontent.com/61977260/193717142-2fd06379-e28c-4e4c-9681-05713bab8263.png)

1. 부모 클래스에 새로운 필드를 하나 추가하면, 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작
2. 자식 클래스에는 부모 클래스의 필드와 메소드만 상속, 생성자와 초기화 블록은 상속X
3. 부모 클래스의 접근 제어가 private이나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근X
4. 단 한 개의 클래스만을 상속받는 단일 상속만이 가능

# super 키워드
🚀 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수
🌱 부모 클래스의 멤버 이름 vs 자식 클래스의 멤버 이름 같을 경우 super 키워드로 구별 -> 부모 클래스의 멤버에 접근

* 사용 대상 : 인스턴스 메소드(상속해주는 클래스의 멤버 값을 사용, 상속받은 클래스의 멤버 값 X)

```
class Parent {
    int a = 10;
}

class Child extends Parent {
    int a = 20;
    
    void display() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}

public class Inheritance03 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
    }
}

```
> 실행 결과 : 20 20 10

# 메소드 오버라이딩
🚀 상속받은 부모 클래스의 메소드를 재정의하여 사용
> private 멤버를 제외한 모든 메소드를 상속 받음
> 
> 그대로 사용 가능, 재정의하여 사용 가능

[ 조건 ]
1. 메소드의 선언부는 기존 메소드와 완전히 같아야 함
2. 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없음
3. 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없음

```
class Parent {
    void display() { System.out.println("부모 클래스의 display() 메소드입니다."); }
}

class Child extends Parent {
    void display() { System.out.println("자식 클래스의 display() 메소드입니다."); }
}

public class Inheritance05 {
    public static void main(String[] args) {
        Parent pa = new Parent();
        pa.display();
        Child ch = new Child();
        ch.display();
        Parent pc = new Child();
        pc.display(); // Child cp = new Parent();
    }
}
```
> 실행 결과 : 부모 자식 자식(다형성 때문)

## 오버로딩(Overloading) vs 오버라이딩(Overriding)
🚀 오버로딩 : 새로운 메소드를 정의

🚀 오버라이딩 : 상속받은 기존의 메소드를 재정의

# 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
* dynamic => runtime, dispatch => 어떤 메소드를 호출할지 결정하는 것
🚀 Upcasting과 Overriding을 통해 runtime Polymorphism을 구현할 수 있음

```
static class Super {
        void print() {
            System.out.println("super's print");
        }
    }

    static class Sub1 extends  Super{
        @Override
        void print() {
            System.out.println("sub1's print");
        }
    }

    static class Sub2 extends Super{
        @Override
        void print() {
            System.out.println("sub2's print");
        }
    }

    public static void main(String[] args) {
        Super reference = new Super(); // 1)
        reference.print();
        reference = new Sub1(); // 2)
        reference.print();
        reference = new Sub2(); // 3)
        reference.print();
    }
```
> 실행 결과 : super's print, sub1's print, sub2's print

* 부모 객체 < 자식 객체 --> Upcasting
* reference가 3개의 객체를 모두 가리키는 것이 아니라 대입될 때마다 순서대로 가리킴

# 추상 클래스
🚀 추상 클래스(abstract class) : 하나 이상의 추상 메소드(자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드)를 포함하는 클래스

[ 선언 ]

```
abstract class 클래스이름{
  ...
  abstract 반환타입 메소드이름();
  ...
}
```

* 추상 클래스는 동작이 정의되어 있지 않은 추상 메소드를 포함하고 있음 -> 인스턴스 생성 X
* 상속 -> 자식 클래스 생성 -> 모든 추상 메소드 오버라이딩 -> 자식 클래스의 인스턴스 생성
* 첫 번째 이유를 통해 반드시 추상 메소드를 구현하기 위해 사용

# final 키워드
🚀 '변경할 수 없다'라는 의미

* 필드, 지역 변수 : 값을 변경할 수 없는 상수(constant)
* 클래스 : 다른 클래스가 상속 받을 수 없음
* 메소드 : 오버라이딩을 통한 재정의 X

```
final class Car {                    // 이 클래스는 상속을 통해 서브 클래스를 생성할 수 없음.
    final int VAR;                   // 이 필드는 상수화되어 값을 변경할 수 없음.
    final void brake() {             // 이 메소드는 오버라이딩을 통해 재정의할 수 없음.
    final double MAX_NUM = 10.2;     // 이 지역 변수는 상수화되어 값을 변경할 수 없음.
    }
}
```

# Object 클래스
🚀 모든 클래스의 부모 클래스가 되는 클래스 

[ 특징 ]
* 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 됌
* 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 Object 클래스의 모든 멤버를 자유롭게 사용 가능
* 모든 객체에서 toString(), clone()과 같은 메소드를 바로 사용할 수 있는 이유

## java.lang package
🌱 가장 기본적인 동작을 수행하는 클래스들의 집합

## java.lang.Object class
🌱 가장 많이 사용되는 클래스

## toString() 메소드
🌱 해당 인스턴스에 대한 정보를 문자열로 반환

* 클래스 이름 @ 16진수 해시 코드
* 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의 되어 있음 -> 각 인스턴스마다 다르게 출력

## equals() 메소드
🌱 해당 인스턴스를 매개변수로 전달받는 참조 변수와 비교하여, 그 결과를 반환 -> 이때 참조 변수가 가리키는 값을 비교 --> 서로 다른 두 객체는 언제나 false

* 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의 되어 있음

## clone() 메소드
🌱 해당 인스턴스를 복제하여, 새로운 인스턴스를 생성해 반환

* clone() 메소드는 단지 필드의 값만을 복사하므로, 필드의 값이 배열이나 인스턴스면 제대로 복제할 수 없음
* 따라서 해당 클래스에서 clone() 메소드를 오버라이딩하여, 복제가 제대로 이루어지도록 재정의해야 함

```
public Object clone() {
        try {
           Car clonedCar = (Car)super.clone();
           // clonedCar.owners = (ArrayList)owners.clone();
            return clonedCar;
       } catch (CloneNotSupportedException ex) {
            ex.printStackTrace();
            return null;
        }
    }
}

public class Object03 {
    public static void main(String[] args) {
       Car car01 = new Car();
       car01.setModelName("아반떼");
       car01.setOwners("홍길동");
       System.out.println("Car01 : " + car01.getModelName() + ", " + car01.getOwners() + "\n"); 
       
       Car car02 = (Car)car01.clone();
       car02.setOwners("이순신"); 
       System.out.println("Car01 : " + car01.getModelName() + ", " + car01.getOwners());
       System.out.println("Car02 : " + car02.getModelName() + ", " + car02.getOwners());
   }
}
```

# 상속 vs Composition
* 둘 다 코드를 재사용하는 방법

## 상속(Inheritance)

```
class Circle extends Point {
    int r;
}
```

## 구성(Composition)

```
class Circle {
    Point c = new Point();
    int r;
}
```

* 언제 상속? 포함 관계? -> Circle is a Point. or Circle has a Point.
* 상속 : is-a relationship 일때
* 구성 : has-a relationship 일때

# 자바는 왜 멀티 상속을 지원하지 않을까?
* 멀티 상속을 구현하면 여러 클래스로부터 상속받기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있음
* 하지만 선언부(이름, 매개변수)가 같고 내용은 다른 인스턴스 메소드가 어떤 클래스로부터 왔는지 추적할 수 없음

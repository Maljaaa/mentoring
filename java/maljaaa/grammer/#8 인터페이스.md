# 인터페이스 정의하는 방법

```
접근제어자 interface 인터페이스이름{
  public static final 타입 상수이름 = 값;
  ...
  public abstract 메소드이름(매개변수목록);
  ...
```

* 모든 필드는 public static final / 모든 메소드는 public abstract

# 인터페이스 구현하는 방법

```
class 클래스이름 implements 인터페이스이름{...}
```

* 직접 인스턴스 생성 X
* 추상 메소드를 구현해 줄 클래스 작성
* 모든 추상 메소드를 구현하지 않는다면, abstract 키워드를 사용하여 추상 클래스로 선언
* 상속과 구현을 동시에 가능
* 다중 인터페이스 상속 가능

# 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

```
public class studyClass implements study{
  // 구현 클래스 메소드
  public void say(){
    System.out.println("this study Class");
  }
}

public static void main(String[] args){
  study study = new studyClass();
  studyClass sudyClass = new studyClass();
  
  study.say();  // 불가능
  studyClass.say();
}
```

* 인터페이스 타입으로 선언한 객체(study)는 구현 클래스(studyClass) 내에서 생성한 메소드, 필드를 사용할 수 없음

# 인터페이스 상속
* 다중 상속

```
class 클래스이름 implements 인터페이스이름1, 인터페이스이름2{
...
}
```

* 인터페이스 간의 상속에는 extends 사용

```
interface ex2{
}
interface ex1 extends ex2{
}
```

# 인터페이스의 기본 메소드 (Default Method), 자바 8

```
interface ex{
  // default 메소드
  default String nameCheck(){
    return "nameCheck";
  }
}
```

* Java 8 이전 : interface의 메소드는 선언만 가능, 구현 x
* Java 8 이후 : 매소드 구현부 가능

# 인터페이스의 static 메소드, 자바 8

* 상속 불가능
* 인터페이스의 상수와 같은 형식으로 쓰임
* interface이름.static메소드이름

# 인터페이스의 private 메소드, 자바 9

* 인터페이스의 메소드는 public인데 java9부터 private를 사용함으로써 외부에 공개하지 않게 하며 코드의 중복을 피하고 interface에 대한 캡슐화 유지 
* private, private static 사용 가능
  * private method : private, abstract, default, static 매소드 호출 가능
  * private static method : static, private static 메소드만 호출 가능

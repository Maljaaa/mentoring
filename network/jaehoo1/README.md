# Network
## TCP
TCP(Transmission Control Protocol)는 IP 프로토콜 위에서 연결형 서비스를 지원하는 전송 계층 프로토콜로, 인터넷 환경에서 기본으로 사용한다.
* 연결형 서비스를 제공 (UDP : 비연결형)
* 전이중(Full Duplex) 방식, 점대점(point to point) 방식
* 신뢰성 있는 데이터 전송, 순차적인 전달을 보장
>전이중 통신(Full Duplex) : 전송이 양방향으로 동시에 일어날 수 있음  
>점대점(point to point) : 각 연결이 정확히 2 개의 종단점을 가지고 있음

TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP는 데이터를 세그먼트(Segment)라는 블록 단위로 분할해 전송한다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.  
  
신뢰성 있는 전달을 위해 오버헤드가 발생하여 UDP보다 속도가 느린 편이다. 속도보다 신뢰성이 중요할 때 사용한다.

### TCP 3 way handshake
TCP가 장치간 논리적인 연결을 성립하기 위해 3 way handshake 방식을 사용한다.  
통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정  
  
![image](https://user-images.githubusercontent.com/44667299/162578377-7b237f0f-d7ee-426f-b641-617b8d228477.png)  
사진 출처 : https://asfirstalways.tistory.com/356  
  
1. 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다. 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다.
2. 서버는 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)와 SYN(b)이 설정된 패킷을 발송한다. 서버는 클라이언트가 ACK으로 응답하기를 기다리는 SYN_RECEIVED 상태가 된다.
3. 클라이언트는 서버의 수락 응답인 ACK(a+1), SYN(b) 패킷을 받고 ACK(b+1)를 서버로 보내면 연결이 성립(ESTABLISHED)된다.
>a : 임의의 번호(random number)  
>b : 서버가 클라이언트에게 주는 번호  
>SYN : SYNchronize sequence number - 요청에 대한 패킷  
>ACK : ACKnowledgement - 응답에 대한 패킷
  
**왜 3 way인가?**  
2번으로는 부족한가? 부족하다.  
좋은 비유가 있어서 가져옴  
클라이언트가 자신의 목소리가 들리는지 물어봄 : SYN(a)  
서버는 클라이언트의 목소리가 들린다고 응답 : ACK(a+1)  
그리고 자신의 목소리가 들리는지 물어봄 : SYN(b)  
클라이언트는 서버의 목소리가 들린다고 응답 : ACK(b+1)  
TCP는 양방향성이다. 클라이언트에서 서버에게 존재를 알리고 패킷이 전송가능함을 알리듯, 서버에서도 클라이언트에게 존재를 알리고 패킷이 전송가능함을 알려야 한다. 그래서 2 way로는 부족하다.  
  
**왜 난수를 사용하나?**  
연결을 맺을 때 사용하는 포트 번호는 시간이 지남에 따라 재사용하는데, 난수가 아니라 순차적인 번호를 사용한다면 이전의 연결에서 오는 패킷으로 인식할 수 있다.

### TCP 4 way handshake
3 way handshake가 TCP의 연결을 초기화 할 때 사용한다면, 4 way handshake는 연결(세션)을 해제하기 위해 사용  
  
![image](https://user-images.githubusercontent.com/44667299/162579953-cf62db42-2f6c-4225-b3fa-e782b17b438c.png)  
  
1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 클라이언트의 요청(FIN)을 받고 일단 확인메시지(ACK)를 보내고 자신의 통신이 끝날 때까지(데이터를 모두 보낼 때까지) 기다린다(TIME_OUT).
3. 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.
4. 클라이언트는 확인했다는 메시지(ACK)를 보낸다.
  
**TIME_WAIT**  
클라이언트는 FIN을 수신했어도 서버에서 FIN을 전송하기 전에 전송한 패킷이 FIN보다 늦게 올 것을 대비해 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는데 이 과정을 TIME_WAIT이라 함  
  
**왜 연결 설정(3 way)과 연결 종료(4 way) 과정이 차이나나?**
* 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 전송할 데이터가 남아있을 수 있음
* 일단 FIN에 대한 ACK 전송 후, 서버의 데이터 전송이 끝나고 FIN을 전송하므로 한 단계 더 거침

### 흐름제어
송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법. 만약 송신측의 전송량이 수신측의 처리량보다 많은 경우, 전송된 패킷은 수신측의 큐(버퍼)를 넘어서 손실될 문제가 발생할 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.  
  
**1) Stop and Wait(정지-대기)**  
* 매번 전송한 패킷에 대한 확인 응답을 받아야 다음 패킷을 전송
* 구조가 간단한 대신, 하나를 주고 하나를 받기 때문에 비효율적

**2) Sliding Window(슬라이딩 윈도우)**
* 수신측에서 설정한 Window size만큼 송신측에서 확인 응답없이 패킷을 전송해, 데이터흐름을 동적으로 조절
* 패킷에 대한 응답이 확인되는 대로 옆으로 Window size만큼 다음 패킷의 데이터를 전송

전송측 윈도우  
![image](https://user-images.githubusercontent.com/44667299/162582043-4de310ed-88e2-4188-b98f-7e94a72dbb98.png)  

수신측 윈도우  
![image](https://user-images.githubusercontent.com/44667299/162582055-87fd0b51-947c-4dc0-86a7-93885adaaaf0.png)  
  
사진 출처 : https://woovictory.github.io/2018/12/28/Network-Erro-Flow-Control/

### 혼잡제어
네트워크에 존재하는 전송 패킷의 수가 많아질수록 네트워크의 성능은 자연스럽게 감소한다. 이와 같은 성능 감소 현상이 급격하게 악화되는 현상을 혼잡(Congestion)이라 한다.  
  
흐름제어는 송신 호스트와 수신 호스트 사이의 논리적인 점대점 전송 속도를 다룬 반면, 혼잡제어는 더 넓은 관점에서 호스트와 라우터를 포함한 서브넷에서 네트워크의 전송 능력 문제를 다룬다.  
  
송신측의 데이터 전송 속도와 네트워크의 데이터 처리속도의 차이를 해결하기 위한 기법  
  
**혼잡의 원인**
* 초기 혼잡 과정에서 타임 아웃 시간이 작으면 혼잡도가 급격히 증가
* 패킷 도착 순서가 다른 상황에서 패킷을 분실 처리하면 타임아웃 증가
* 의도적으로 피기배킹을 사용하면 응답시간이 느려져 타임아웃 증가
* 패킷 생존 시간을 작게 하면 패킷이 강제로 제거되어 타임아웃 증가
* 라우팅 알고리즘 : 혼잡이 발생하지 않는 경로를 설계해야 함
* 혼잡이 발생하는 경로를 선택하면 혼잡이 주변으로 확대됨
>피기배킹(Piggybacking) : 양방향으로 동시에 정보 프레임과 응답 프레임을 교차하여 전송하는 경우를 사용하는 방식이다. 정보 프레임과 응답 프레임을 각각 보내는 것이 아니라 정보 프레임을 전송하면서 응답 기능까지 동시에 수행하도록 프레임 구조를 변형시킨 것이다. 이렇게 되면 응답 프레임의 전송 횟수를 줄이는 효과가 있어 전송 효율을 높일 수 있다.  
>피기배킹 방식을 사용하는 응답 방식은 혼잡이 발생했을 때 송신 호스트의 타임아웃 기능을 통한 재전송을 유발하여 혼잡을 오히려 가중시킬 우려도 있다.

<br/>  

**1) AIMD(Additive Increase / Muticative Decreas)(합 증가 / 곱 감소)**  
처음에 패킷을 하나씩 보내고 이것이 문제없이 도착할 경우 윈도 크기를 1씩 증가시켜 가면서 전송하는 방법이다. 만약 패킷 전송에 실패하거나 일정 시간을 넘길 경우 패킷을 보내는 속도를 절반으로 줄인다.  
  
공평한 방식으로 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다.  
  
초기에는 네트워크의 높은 대역폭을 사용하지 못하기 때문에 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다는 문제점이 있다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.  
<br/>  

**2) Slow Start**  
미리 정해진 임계치에 도달할 때까지 원도의 크기를 2배씩 증가시킨다.  
  
AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있다.  
  
Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고 패킷이 문제없이 도착할 경우 각각의 ACK 패킷마다 윈도 사이즈를 1씩 늘려준다. 즉, 한 주기가 지나면 윈도 사이즈가 2배가 되기 때문에 선형적으로 증가하지 않고 지수적으로 증가한다. 대신 혼잡현상이 발생할 경우는 윈도의 크기를 1로 떨어뜨리게 된다.  
  
처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다. 그러므로 혼잡 현상이 발생했던 윈도 크기 절반까지는 지수로 윈도 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
1. 초기 혼잡 Window Size 1로 전송 = 전송 호스트는 하나의 패킷만 전송
2. 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송
3. 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 4로 하여 전송
4. 수신 호스트로부터 수신응답을 수신하면 윈도위의 크기를 8로 하여 전송
* 미리 정해진 임계 값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
* 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다.

전송되는 데이터 크기가 임계 값에 도달할 경우 혼잡 회피 단계로 넘어간다.  
<br/>  

**3) Congestion Avoidance(혼잡 회피)**  
느린 출발의 지수적 증가가 임계치에 도달하게 되면 혼잡으로 간주하고, 회피를 위해 주고받는 윈도 크기가 선형적으로 증가하여 혼잡을 예방한다.  
  
윈도 크기가 임계 값에 도달한 이후에는 혼잡에 의해 데이터 손실이 발생할 확률이 높아지게 된다. 그렇기에 데이터를 전송하는 데 있어서 조심하는 단계이다.  
  
전송한 데이터에 대한 ACK를 받으면 윈도우의 크기를 1씩 증가시킨다.  
전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.
* 수신 측으로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우
  * 타임아웃 발생
  * 네트워크에 혼잡이 발생했다고 인식
    * 윈도우의 크기를 1로 줄임
    * 임계 값을 패킷 손실이 발생하였을 때의 윈도 크기의 반으로 줄임

<br/>  

**4) Fast Retransmission(빠른 재전송)**  
송신 측에서 3개의 중복 패킷을 받게 되면 해당 패킷이 손실되었다고 간주해 타임아웃을 기다리지 않고(타임아웃이 발생하기 전에) 즉시 재전송한다.  
이 현상이 일어난 것은 약간의 혼잡이 발생한 것이므로 Window Size를 반으로 줄인다.  
<br/>  

**5) Fast Recovery(빠른 회복)**  
빠른 재전송 이후 느린 출발이 아닌 혼잡 회피 상태에서 선형적 전송을 하는 기법이다.  
  
빠른 회복 정책은 혼잡한 상태가 되면 윈도 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 합 증가/곱 감소 방식으로 동작하게 된다.  
<br/>  

**6) TCP Reno**  
N개의 중복 ACK 발생 시 ssthresh(slow start threshold)값을 Congestion Window(cwnd) 사이즈의 반으로 줄여 빠른 복구(Fast Recovery)를 수행하여 선형적 증가를 하게 되며, TCP Time Out에 이르면 Slow Start를 시작한다.  
<br/>  

**7) TCP Tahoe**  
N개의 중복 ACK 발생 시 바로 Slow Start를 시작한다.  
  
TCP Tahoe와 TCP Reno는 ssthresh(slow start threshold) 값까지 지수적 증가(Slow Start)를 하게 되고 ssthresh를 넘어서면 선형적 증가(Additive Increase)를 하는 것까지는 동일하다. 차이가 생기는 기준은 N개의 중복 ACK가 발생할 경우이다.

### 오류제어
전송된 데이터의 오류를 검출/정정하는 기법  
  
**오류 인지**  
오류를 제어하기 위해선 먼저 오류가 발생했음을 인지 해야함  
TCP 에서 오류를 파악하는 방법은 크게 두가지
1. 수신측에서 송신측으로 명시적으로 NAK 를 전송
2. 전송한 패킷에 대한 ACK 가 오지 않거나 중복된 ACK 가 전송될 때

중복된 ACK 란 보통 3개 이상이 전달 될 때 오류 발생으로 파악하며 1번 방법 사용시 송신측에 NAK를 확인하는 새로운 로직이 필요하기 때문에 일반적으로 2번 방법을 적용해 오류를 인지한다.  
<br/>  

**ARQ(Automatic Repeat reQuest)**
* 수신 측에서 수신한 정보에 오류가 있을 경우, 송신측에 재전송을 요청해 오류를 제어하는 방식
* 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다. ARQ 기법은 흐름 제어 기법과 연관되어 있다.

**1) Stop and Wait ARQ**  
데이터를 보내면 제대로 받았다라는 응답이 올 때까지 대기  
  
![image](https://user-images.githubusercontent.com/44667299/162610241-711d4100-6599-45f3-8283-ec2c23900cd8.png)  
사진 출처 : https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/
* 송신측에서 한 개의 프레임을 전송한 후 수신 측으로부터 응답(ACK/NAK)을 기다리는 기법
* 구현이 간단
* 프레임을 전송할 때마다 응답을 기다리므로 전송 효율이 낮음
* 수신측에 데이터를 받지 못했을 경우 NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다.
* 만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송한다.

<br/>  

**2) Go Back N ARQ**  
데이터를 연속적으로 보내다가 그 중 어느 데이터부터 오류가 발생했는지를 검사하는 방식  
  
![image](https://user-images.githubusercontent.com/44667299/162610307-e26b940a-1577-4ca2-ab02-b5e3121e0857.png)  
  
전송된 프레임이 손상되거나 분실될 경우, 그리고 ACK 패킷의 손실로 인한 TIME_OUT이 발생한 경우, 확인된 마지막 프레임 이후로 모두 재전송하는 기법
* 오류가 난 지점부터 전송한 지점까지 모두 재전송하는 기법
* 수신측에서 NAK을 보내면 송신측이 오류가 발생한 이후의(NAK 프레임 번호부터) 프레임을 모두 재송신
  * 수신측은 원하는 프레임이 아닐 경우, 데이터를 모두 폐기 처분한다.
  * 타임아웃(ACK 분실)의 경우, 마지막 ACK된 데이터부터 재전송한다.
* 전송오류가 발생하지 않으면 쉬지 않고 송신 가능
* 중복전송의 단점

<br/>  

**3) Selective Repeat ARQ(SR ARQ)**  
말 그대로 선택적인 재전송을 의미. Go Back N 방법도 Stop and Wait에 비하면 많이 효율적인 방법이지만, 에러가 발생하면 그 이후에 정상적으로 전송되었던 데이터까지 모두 폐기 처분되어 다시 전송해야한다는 비효율이 아직 존재. 그래서 에러난 데이터만 재전송하는 방식  
  
![image](https://user-images.githubusercontent.com/44667299/162613439-059c04ee-7dda-422f-a5d6-57a4453a986c.png)  

* 여러 프레임을 연속적으로 전송하고, 수신측에서 NAK을 보내면 송신측에서는 오류가 난 부분의 프레임만 재전송
* 수신측에서는 오류가 발생할 경우, 해당 프레임을 재전송받을 때까지, 이후의 프레임을 버퍼에 담아놨다가 재조립하는 과정이 필요

얼핏 보면 이 방식이 굉장히 효율적이고 좋기만 한 것 같지만 Stop and Wait와 Go Back N 방식과 다르게, 이 방식을 사용하는 수신 측의 버퍼에 쌓인 데이터가 연속적이지 않다는 단점이 존재한다.  
  
위 예시만 봐도 수신 측의 버퍼에는 0, 1, 2, 3, 4, 5가 순차적으로 들어있는 것이 아니라, 중간에 폐기 처분된 4를 제외한 0, 1, 2, 3, 5만 버퍼에 존재할 것이기 때문이다. 이때 송신 측이 4를 재전송하게되면 수신 측은 이 데이터를 버퍼 중간 어딘가에 끼워넣어서 데이터를 정렬해야한다.  
  
이때 같은 버퍼 안에서 데이터를 정렬할 수는 없으니, 별도의 버퍼가 필요하게 된다.
|Go Back N ARQ|Selective Repeat ARQ|
|:---:|:---:|
|손상/분실된 프레임 이후의 프레임을 모두 재전송|손상/분실된 프레임만을 재전송|
|비교적 간단, 구현이 쉬움|구조가 복잡(프레임 재배열 등의 추가 로직 필요)|
|추가 버퍼 필요 없음(데이터 폐기 방식을 사용)|정렬을 위한 추가적인 버퍼 공간이 필요|
|SR ARQ에 비해 비용이 비교적 저렴|유지 관리 비용이 큼|

<br/>  

**4) Adaptive ARQ**  
* 전송 효율을 최대로 하기위해 데이터 프레임의 길이를 (채널의 상태에 따라) 동적으로 변경
* 수신측은 오류 발생률을 판단해 송신측에 통보
* 송신측은 오류 발생률에 따라 프레임 길이를 동적으로 조절
* 효율이 좋음
* 많은 비용 발생

전송 효율이 제일 좋으나, 제어 회로가 복잡하고 비용이 많이 들어 현재는 거의 사용을 안 한다.

## UDP
UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 이다.(3 way 같은 연결 설정을 하지 않음)  
  
TCP와는 대비되게 신뢰성(흐름/오류제어)을 포기하고 전송속도를 얻었다. Best Effort 전달 방식을 지원한다.
>Best Effort : 서비스의 quality를 보장하지 않음

프로토콜을 처리하는 기능이 작아 TCP보다 데이터 처리가 빠르므로 데이터 전송 시간에 민감한 응용 환경에서는 UDP를 사용하는 것이 유리하다.  
 → 신뢰성보다 속도가 중요한 상황에 UDP를 사용  
   
ex : 3개의 데이터(패킷)를 전송할 때, 만약 이들간에 연결성(연관성)이 있다면 UDP를 안쓰는게 좋다

|프로토콜|TCP|UDP|
|:---:|:---:|:---:|
|연결 방식|연결형 서비스|비연결형 서비스|
|패킷 교환 방식|가상회선 방식|데이터그램 방식|
|전송 순서|보장|보장하지 않음|
|수신 여부 확인|확인|확인하지 않음|
|통신 방식|Unicast 지원|Unicast, Multicast, Broadcast 지원|
|신뢰성|높음|낮음|
|속도|느림|빠름|

## HTTP
HyperText Transfer Protocol
* 분산 하이퍼미디어 환경에서 빠르고 간편하게 데이터(웹문서)를 전송하는 프로토콜
* 웹 상에서 클라이언트와 서버 간 Request/Response로 정보를 주고 받을 수 있는 프로토콜
* 주로 HTML 문서를 주고 받음
* 포트 80번 사용
* 비연결성(Connectionless) : 클라이언트가 요청을 전송하고 서버가 이에 대한 응답을 하면 바로 연결이 끊어지는 특성
* 무상태성(Stateless) : 연결 끊어진 후에 상태 정보를 유지하지 않는 특성

<br/>  

**HTTP의 요청과 응답**  
RFC 2616으로 발표된 HTTP 1.1 버전은 클라이언트의 요청과 서버의 응답에 의해 동작하는 아주 간단한 프로토콜이다.
* HTTP 클라이언트가 서버에 요청을 전송한다. 요청 내용에는 프로토콜 명령에 해당하는 요청 메서드, URL, HTTP 버전이 포함되며, 기타 클라이언트의 요청과 관련된 부가 정보도 포함한다.
* HTTP 서버는 요청의 처리 결과를 의미하는 응답 코드가 포함된 상태 정보를 회신한다. 클라이언트가 요청한 결과물이나 기타 정보도 함께 회신한다.

<br/>  

**요청 메서드(Request Method)**  
클라이언트가 서버에 실행을 요구하는 명령을 기술
|명령|설명|
|---|---|
|GET|클라이언트가 서버에 URL이 가리키는 웹 문서의 내용을 전송하도록 요구한다. 문서 내용은 서버가 회신하는 응답 메시지의 바디에 포함된다.|
|HEAD|문서 내용보다는 특정 문서의 정보를 원할 때 사용한다.|
|POST|클라이언트가 서버에 정보를 전송할 수 있도록 해준다. 보통 게시판, 방명록처럼 사용자가 입력한 정보를 서버에 전달하는 용도로 사용한다.|
|PUT|클라이언트가 서버에 문서를 전달하려고 사용한다. 문서 내용은 바디에 포함된다.|

**HTTP 상태 코드**
|코드|이름|의미|
|---|---|---|
|200|OK|요청이 성공적으로 수행되었다.|
|202|Accepted|클라이언트의 요청을 수신하였으나, 즉각 실행되지 않고 있다.|
|400|Bad Request|요청 메시지의 내용에 문법 오류가 존재한다.|
|401|Unauthorized|요청을 실행하는 데 필요한 적절한 권한이 존재하지 않는다.|
|403|Forbidden|서비스 요청이 거부되었다.|
|404|Not Found|원하는 문서를 찾을 수 없다.|
|500|Internal Server Error|서버 내부에 불가피한 오류가 발생하였다.|
|501|Not Implemented|요청 사항을 수행할 수 없다.|
|502|Bad Gateway|서버가 요청을 처리하는 데 필요한 응답을 얻기 위해 게이트웨이로 작업하는 동안 잘못된 응답을 수신했다.|
|503|Service Unavailable|서버가 요청을 처리할 준비가 되지 않았다. 일반적인 원인은 유지보수를 위해 작동이 중단되거나 과부하가 걸렸을 때|
|504|Gateway Timeout|서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 제때 요청을 받지 못했다. 적시에 응답을 받을 수 없을 때 주어진다.|

<br/>  

**요청 메시지 예시**  
![image](https://user-images.githubusercontent.com/44667299/162615379-e7b91c0d-e7e6-4d08-a8cb-f67101cd8a83.png)  
  
요청 메서드, URL, HTTP 버전, 서버주소  

<br/>  

**응답 메시지 예시**  
![image](https://user-images.githubusercontent.com/44667299/162615460-0a6f9eb2-d1dd-4154-a1fe-3d330ae642c4.png)  
  
<br/>  

**주소창에 URL을 입력하면 일어나는 일련의 과정**
1. 사용자가 브라우저를 통해 URL 주소 입력
2. DNS 서버를 통해 해당 도메인의 IP 주소를 받아 함께 전달
3. URL 정보와 IP 주소는 HTTP 프로토콜을 사용해 HTTP request 메시지 생성
4. TCP 프로토콜을 사용해 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송
5. HTTP Request 메시지는 HTTP 프로토콜을 사용해 URL 정보로 변환
6. 서버는 도착한 URL 정보에 해당하는 데이터 검색
7. 검색된 데이터는 HTTP 프로토콜을 사용해 HTTP response 메시지 생성
8. HTTP response 메시지는 TCP 프로토콜을 거쳐 원래 컴퓨터로 전송
9. HTTP response 메시지는 HTTP 프로토콜을 사용해 웹 페이지로 변환
10. 변환된 웹 페이지는 브라우저를 통해 사용자에게 제공

### HTTP 버전
**HTTP 0.9**  
HTTP의 초기 버전에는 버전 정보가 없었고 차후에 구분을 위해 0.9라고 불리게 되었다.
* 특징
  * HTTP 초기 버전을 구분하기 위해 부르는 버전 (1991년)
  * 요청은 단일 라인으로 구성되며, 리소스에 대한 method는 GET만 존재
  * 응답도 극도로 단순 (파일 내용 자체로만 구성)
  * HTTP 헤더도 없고, HTML파일만 전송 가능했던 것이 특징
  * 상태 혹은 오류 코드가 없기 때문에 문제의 상황시 해당 파일 내부에 문제에 대한 설명을 포함하여 보냄
* 요청/응답 예시
```html
/* 요청 */
GET /mypage.html

/* 응답 */
<HTML>
A very simple HTML page
</HTML>
```

<br/>  

**HTTP 1.0**  
HTTP/0.9는 매우 제한적이었으며 브라우저와 서버 모두 좀 더 융통성을 가지도록 빠르게 확장되었다.
* 특징
  * HTTP 헤더(header) 개념이 도입되어 요청과 응답에 추가되며, 메타데이터를 주고 받고 프로토콜을 유연하고 확장 가능하도록 개선됨 (1996년)
  * 버전 정보와 요청 method가 함께 전송되기 시작
  * 상태 코드 라인도 응답의 시작부분에 추가되어 브라우저 요청의 성공과 실패를 파악 가능해짐 (해당 결과에 대한 로컬 캐시 갱신 등의 사용이 가능해짐)
  * Content-Type 도입으로 HTML 이외의 문서 전송 기능이 가능해짐
* 한계
  * 커넥션 하나당 요청 하나와 응답 하나만 처리 가능했음
    * 지금 생각해보면 매우 비효율적인 동작으로 보이며, 서버 부하도 문제
    * HTTP 1.1에서 개선
* 요청/응답 예시
```html
/* 요청 */
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

/* 응답 */
200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML>
A page with an image
  <IMG SRC="/myimage.gif">
</HTML>
```

<br/>  

**HTTP 1.1**  
HTTP/1.1은 HTTP의 첫번째 표준 버전이다. 눈에 잘 보이는 추가점은 메서드에 OPTIONS, PUT, DELETE, TRACE 가 추가되었다. 그리고 헤더값도 몇 가지 추가되었다.  
  
추가된 헤더 예시
```text
Via : 중계서버(프록시, 게이트웨이 등)의 지원 프로토이름.버전.호스트명 (ex. via: 1.1 123abc.cloudfront.net (CloudFront))
Accept : 클라이언트의 사용가능 미디어타입 (ex. application/json, text/plain, */*)
…
```
* 특징
  * Persistent Connection 추가
    * 지정한 timemout 동안 커넥션을 닫지 않는 방법을 통해 커넥션의 사용성이 높아짐
    * 커넥션이 재사용될 수 있게 하여, 탐색된 단일 원본 문서 내로 임베드된 리소스들을 디스플레이하기 위해 사용된 커넥션을 다시 열어 시간을 절약
  * Pipelining 추가
    * 앞 요청의 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내고 그 순서에 맞춰 응답을 받는 방식이 등장
    * 순차적으로 하나씩 요청 / 응답이 처리되는 기존 방식을 개선
    * 하나의 커넥션에 여러개의 요청이 들어 있을 뿐, 동시에 여러개의 요청을 처리해 응답으로 보내주는 것은 아니다 (multiplexing 되지는 않음)
  * 추가적인 캐시 제어 메커니즘이 도입
  * 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입되어, 클라이언트와 서버로 하여금 교환하려는 가장 적합한 컨텐츠에 대한 동의를 가능케 함
  * Host 헤더 덕분에, 동일 IP 주소에 다른 도메인을 호스트하는 기능이 서버 코로케이션을 가능케 함
* 한계
  * Head Of Line Blocking(HOL)
    * 결국 앞 요청의 응답이 너무 오래걸리면 뒤 요청은 Blocking 되어버림
  * Header 구조의 중복
    * 연속된 요청의 헤더의 많은 중복이 발생
* 요청/응답 예시
```html
/* 요청 */
GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

/* 응답 */
200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)
```

<br/>  

**HTTP 2.0**  
더 나은 성능을 위한 프로토콜  
Google은 SPDY 프로토콜을 구현하여 HTTP/2 프로토콜의 기초로써 기여했다.  
  
기존 HTTP 1.X 버전의 성능 향상에 초점을 맞춘 프로토콜 (2015년 등장)  
표준의 대체가 아닌 확장 (표준 : HTTP 1.1)

* HTTP 메시지 전송 방식의 전환
* 기존 : 일반 텍스트 형식
* 개선
  * Binary Framing 계층을 추가해서 보내는 메시지를 프레임(frame)이라는 단위로 분할하며 추가적으로 바이너리로 인코딩을 한다 (바이너리 형식 사용으로 파싱속도 및 전송 속도가 빠르고 오류 발생 가능성이 낮아짐)

* 특징
  * HTTP 메시지 전송 방식의 전환
  * Multiplexed Streams
  * Stream Prioritization
  * Server Push
  * Header Compression

>**Multiplexed Streams(요청 및 응답 다중화)**
>* HTTP 1.1 에서는 한번에 커넥션을 맺고 데이터를 요청하고 응답받고를 반복하는데, HTTP 2에서는 스트림(stream)으로 한번의 커넥션으로 동시에 여러 개의 데이터를 주고 받을 수 있다. 이렇게 하여 HTTP 1.x 에서의 이미지 스프라이트, 도메인 분할 같은 임시방편을 사용하지 않아도 된다.
>* Stream을 통해서 각 요청의 응답의 순서가 의미가 없어져서 HOL Blocking이 자연스럽게 해결됨

>**Stream Prioritization(스트림 우선 순위)**
>* 리소스간 우선순위를 설정하는 기능
>* 스트림의 프레임으로 다중화가 가능해짐과 동시에 클라이언트와 서버의 통신 순서를 위해 각 스트림에는 1~256 사이의 정수 가중치가 할당되어 스트림 처리 우선순위를 정한다. 그런데 이게 우선 순위를 지정하여 이를 처리할 CPU, 메모리 및 기타 리소스의 할당을 제어하는 것일 뿐 특정 순서로 처리되도록 서버에 강요될 순 없다.

>**Server Push**
>* 단일 클라이언트 요청에 여러 응답을 보낼 수 있는 특징을 통해 Server에서 Client에게 필요한 추가적인 리소스를 push해주는 기능

>**Header Compression(헤더 압축)**
>* HTTP 1.x의 경우에는 가령 두 개의 동일한 요청을 보낸다고 했을 때, 두 개의 헤더에 중복값이 존재해도 모두 전송한다, HTTP 2에서는 HPACK 압축형식을 사용해서 요청 및 응답 헤더 메타데이터를 압축하는데 이때 이 중복되는 헤더값을 색인값으로 처리해준다.
>* 기존 : 연속된 요청의 경우 많은 중복된 헤더의 전송으로 오버헤드가 많이발생했음
>* 개선
>* 요청과 응답의 헤더 메타데이터를 압축해서 오버헤드를 감소
>* 1) 전송되는 헤더 필드를 static dynamic table로 서버에서 유지
>* 2) 이전에 표시된 헤더를 제외한 필드를 허프만(huffman) 인코딩을 수행해서 데이터를 압축

* 한계
  * 각 요청마다 Stream으로 구분해서 병렬적으로 처리하지만, 결국 이에는 TCP 고유의 HOL Blocking이 존재
  * 왜냐하면, 서로 다른 Stream이 전송되고 있을 때, 하나의 Stream에서 유실이 발생되거나 문제가 생기면 결국 다른 Stream도 문제가 해결될 때 까지 지연되는 현상이 발생되기 때문
  * 즉, 이러한 TCP의 태생적인 HOL Blocking을 해결하기 위해 QUIC / HTTP3.0이 등장

<br/>  

**HTTP 3.0 / QUIC**  
* QUIC
  * Google에서 개발한 UDP 기반의 전송 프로토콜 (Quick UDP Internet Connections)
  * Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택
  * QUIC은 TCP의 3 way handshake과정을 최적화 하는 것에 초점을 두고 개발됨
  * QUIC은 TCP의 Stream은 하나의 chain으로 연결되는 것과 다르게 각 Stream당 독립된 Stream chain을 구성하여 TCP HOL Blocking을 해결하였다
* HTTP 3.0
  * QUIC을 기반으로 나온 새로운 HTTP 메이저 버전

## HTTPS
* HTTP에서 보안이 강화(암호화, 인증, 완전성 보호)된 버전의 프로토콜
* HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) / TLS(Transport Layer Security)라는 프로토콜로 대체
* 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어가 지원하는 암호화 알고리즘에 의존

HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신 하게 된다. SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.  
  
HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.

**장점**
* 통신 중간에 제 3자가 정보를 가로챌 수 없으므로 안전

**단점**
* 암호화 하는 과정이 웹 서버에 부하를 줌
* HTTPS는 설치 및 인증서를 유지하는데 추가 비용 발생
* 느림
* 인터넷 연결이 끊긴 경우 재인증 시간이 소요

### HTTPS가 필요 이유
**HTTP의 문제점**
* HTTP 는 평문 통신이기 때문에 도청이 가능하다. → Wireshark 등을 이용한 패킷 스니핑(Sniffing)
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다. → 스푸핑(Spoofing)
* 완전성을 증명할 수 없기 때문에 변조가 가능하다. → Burp Suite 등을 활용한 패킷 위변조

<br/>  

**도청 가능**  
HTTP는 평문 통신이기 때문에 Wireshark 등을 사용하여 패킷을 캡쳐하는 것만으로도 도청할 수 있다.  
(만일 어느 페이지에 로그인을 하는데, 프로토콜이 HTTP라면 이 때 패킷을 캡쳐하면 ID/PW를 알아낼 수 있다)  
SSL/TLS를 사용하여 암호화 해야 함  
  
**위장 가능**  
HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼 수 있다.  
SSL을 사용하여 서버나 클라이언트의 실재 사실을 증명해야 함  
  
**변조 가능**  
서버와 클라이언트의 통신 사이에 누군가(중간자)가 끼어들어서 통신(패킷)을 변조할 수 있다.  
SSL에는 인증이나 암호화, 그리고 다이제스트(해시값) 기능이 있다.  
  
번외로, 요즘엔 하드웨어의 발달로 HTTPS를 사용해도 성능 저하가 거의 없다고 한다.

### HTTPS HandShake
![image](https://user-images.githubusercontent.com/44667299/162749214-8b1c9b08-c217-403a-8a18-178dc56152f6.png)  
사진 출처 : https://brunch.co.kr/@sangjinkang/38  
  
HTTPS가 TCP 기반의 프로토콜이기 때문에 암호화 협상(SSL HandShake)에 앞서 3 way handshake를 진행함
1. 컴퓨터(브라우저)가 자신의 버전, 암호 알고리즘 목록, 사용 가능한 압축 방식을 Client Hello 메시지에 담아 서버로 전송
2. 클라이언트가 제공한 암호 알고리즘 목록, 압축 방식 목록 중 선택 & 세션 ID, CA에서 사인한 서버의 공개 인증서를 Server Hello에 담아 전송
3. 브라우저는 서버의 SSL 인증서가 믿을만한지 확인. 서버가 보낸 SSL 인증서가 CA 목록에 있는지 확인
4. SSL이 확인되면 클라이언트와 서버가 사용할 대칭키를 형성하기 위해 난수 바이트를 생성해 서버의 공개키로 암호화 후 전송
5. 클라이언트가 보낸 대칭키를 서버의 개인키로 복호화

## GET VS POST
둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식  
둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야 함

### GET(가져오다)
GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분에 url에 담겨서 전송된다. url 상에 ? 뒤에 데이터가 붙어 request 를 보냄  
로그인 할 때 비밀번호가 url에 노출되면 안된다!  
  
GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다.  
(데이터를 조회하는 성향이며, DML의 SELECT와 비슷하다고 생각하면 되겠다)  
GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재

### POST(게시하다)
POST 방식은 요청하는 데이터가 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다.  
  
POST는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

## 쿠키와 세션
HTTP 프로토콜이 가지는 비연결성, 무상태 특징이 있다. 클라이언트의 상태를 저장하거나 이전 요청과 현재 요청이 같은 사용자로부터의 요청인지 알기 위해 상태를 유지해야 할 필요성(ex : 로그인)이 있는데, 이때 쿠키 또는 세션을 사용한다

### 쿠키
* 클라이언트에 대한 상태 정보를 key와 value의 형태로 로컬에 저장해 참조하는 방식
* 클라이언트의 상태 정보를 브라우저에 저장해 참조

<br/>  

* 동작 방식
  * 웹 브라우저가 서버에 요청
  * 상태를 유지하고 싶은 값을 쿠키(Cookie)로 생성
  * 서버가 응답할 때 HTTP 헤더(Set-cookie)에 쿠키 정보를 포함해 전송
  * 전달받은 쿠키는 웹 브라우저에서 관리하고 있다가, 다음 요청 시 쿠키를 HTTP 헤더에 넣어서 전송
  * 서버에서 쿠키 정보를 읽어 이전 상태 정보와 일치하는 지 확인 후 응답
* 사용 예
  * 아이디와 비밀번호 저장
  * 쇼핑몰 장바구니

### 세션
* 일정시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술

<br/>  

* 동작 방식
  * 웹 브라우저가 서버에 요청
  * 서버가 해당 웹 브라우저(클라이언트)에 세션 ID를 부여
  * 서버가 응답할 때 HTTP 헤더(Set-cookie)에 세션 ID를 포함해 전송
  * 웹 브라우저는 이후 웹 브라우저를 닫기까지 다음 요청 때 부여된 세션 ID가 담겨있는 쿠키를 HTTP 헤더에 담아 전송
  * 서버는 세션 ID를 확인 후 해당 세션에 관련된 정보를 확인하고 응답
* 사용 예
  * 로그인

||쿠키|세션|
|:---:|:---:|:---:|
|저장위치|클라이언트|서버|
|보안|취약|비교적|안전|
|라이프|사이클|만료시간|브라우저의 종료|
|속도|빠름|느림|

## REST와 RESTful의 개념
### REST
Representational State Transfer  
* 자원을 이름 (자원의 표현)으로 구분하여 해당 자원의 상태 (정보)를 주고 받는 모든 것을 의미
* 즉, 자원(resource)의 표현(representation) 에 의한 상태 전달
* 월드 와이드 웹(WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
  * REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
  * REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.
* HTTP URI를 통해 자원을 명시하고, HTTP Method (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의미한다.
* 즉, REST는 자원 기반의 구조 (ROA: Resource Oriented Architecture) 설계의 중심에 Resoure가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
* 웹의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.
* REST 구성 요소
  * 자원 : URI
    * 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
    * Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.
  * 행위 : HTTP Method
    * GET, POST, PUT, DELETE
  * 표현
    * Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
    * REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다.
>URI : 네트워크 상에서 자원을 식별하기 위한 문자열의 구성. 특정 리소스를 식별하는 통합 자원 식별자(Uniform Resource Identifier)  
>URL : 웹 주소. 자원의 위치를 나타내는 주소  
>URL ⊆ URI

<br/>  

**REST가 필요한 이유**
* 애플리케이션 분리 및 통합
* 다양한 클라이언트의 등장. 최근의 서버 프로그램은 다양한 브라우저와 안드로이폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
* 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.

### RESTful
* RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
  * REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있다.
* RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다.
  * 즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.

<br/>  

**왜 RESTful APIs를 만드는 것일까?**
* Client Side를 정형화된 플랫폼이 아닌 모바일, PC, 어플리케이션 등 플랫폼에 제약을 두지 않는 것을 목표로 했기 때문
* 스마트폰의 보급 전에는 Server Side에서 데이터를 전달해주는 Client 프로그램의 대상은 PC 브라우저로 그 대상이 명확 했다. 그렇다 보니 그냥 JSP ASP PHP 등을 이용한 웹페이지를 구성하고 작업을 진행하면 됐다.
* 하지만 스마트 기기들이 등장하면서 TV, 스마트 폰, 태블릿 등 Client 프로그램이 다양화 되고 그에 맞춰 Server를 일일이 만다는 것이 꽤 비효율적인 일이 되어 버렸다.
* 이 과정에서 개발자들은 Client Side를 전혀 고려하지 않고 메시지 기반, XML, JSON과 같은 Client에서 바로 객체로 치환 가능한 형태의 데이터 통신을 지향하게 되면서 Server와 Client의 역할을 분리하게 되었다.
>이런 변화를 겪으면서 필요해진 것은 HTTP 표준 규약을 지키면서 API를 만드는 것이다.

**RESTful의 목적**
* 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
* RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다.

## DNS 흐름

### DNS round robin 방식
### DNS Round Robin 방식의 문제점
### Weighted round robin (WRR)
### Least connection
## Socket(TCP/IP Socket) 
### Socket 이전 실시간 통신 기술들 
### 클라이언트 소켓과 서버 소켓      
### 소켓 API 실행흐름  
## Web Socket(HttpSocket) 
### Web Socket HandShake 및 실행 흐름 
### WebSocket 한계 
> Socket.io 및 SocketJS
> STOMP - SubSocket 
## CORS
## OSI 7Layer VS TCP/IP 4Layer VS TCP/IP 5Layer
## 웹 통신 전체 흐름 

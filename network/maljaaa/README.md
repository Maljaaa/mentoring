# Network

## 기초 개념 정리

* 네트워크(Network) : 프로토콜을 사용하여 데이터를 통신(교환)하는 시스템의 집합
* 프로토콜(Protocol) : 전송 매체를 통해 데이터를 교환할 때 따르는 표준화된 특정 규칙(시스템이 데이터를 교환할 때 임의의 통신 규칙, 동등관계)
* 표준화(standardization) : 서로 다른 시스템을 상호 연동해 동작시킬 때 필요한 연동 형식의 통일
* 인터넷(Internet) : 전 세계에 걸쳐 파일 전송 등의 데이터 통신 서비스를 받을 수 있는 컴퓨터 네트워크의 시스템
* 시스템(System) : 내부 규칙에 따라 능동적으로 동작하는 대상(목적을 갖는 복잡한 존재)
* 인터페이스(Interface) : 시스템과 시스템을 연결하기 위한 표준화된 접근 방법(시스템과 전송 매체의 연결 지점에 대한 규격)
* 전송 매체(Transmission Media) : 시스템끼리 정해진 인터페이스를 연동해 데이터를 전달하는 물리적인 전송 수단(케이블, 공기, 무선신호 등)
* 노드(Node) : 인터넷에 연결된 시스템을 가장 일반화한 용어
* 호스트(Host) : 네트워크에 연결되어 있는 컴퓨터(컴퓨팅 기능이 있는 시스템)
* 클라이언트(Client) : 서비스를 이용하는 시스템
* 서버(Server) : 서비스를 제공하는 시스템
* 인터네트워킹(Internetworking) : 네트워크와 네트워크의 연결
* 게이트웨이(Gateway) : 인터네트워킹 기능을 수행하는 시스템
* 리피터(Repeater) : 한쪽에서 입력된 신호를 물리적으로 단순히 증폭(물리적 신호는 전송 거리가 멀수록 감쇄되기 때문에 중간에 이를 보완해줘야함)
* 라우터(Router) : 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비
* 라우팅 테이블(Routing Table) : 네트워크와 호스트에 대한 정보가 보관되는 장소
* 교환(Switching) : 데이터를 최종 목적지까지 올바른 경로로 중개하는 기능
* 회선 교환(Circuit Switching) : 고정 대역으로 할당된 연결을 설정하여 데이터를 전송
* 패킷 교환(Packet Switching) : 데이터를 미리 패킷 단위로 나누어 전송(전용 대역을 따로 할당하지 않기 때문에 가변 크기의 전송률 지원)
* 데이터그램(Datagram) : 패킷들이 각각의 경로로 전송
* 가상회선(Virtual Circuit) : 패킷 교환에서 모든 패킷의 경로를 일정하게 

## OSI 7계층 모델

🚀 ISO(International Standard Organization)에서 제시한 OSI 7계층 모델, 연결된 두 호스트가 각각 7개 계층으로 구성된 모듈을 수행함으로써 데이터 송수신이 가능

![image](http://wiki.hash.kr/images/7/71/OSI_7_%EA%B3%84%EC%B8%B5.jpg)  

> 계층 n 프로토콜 : 계층 n 모듈끼리 사용하는 통신 규칙<br>
> 동료 프로세스 : 동일 계층에 위치한 통신 양단 프로세스<br>
> 인터페이스 : 상하위 계층 사이의 접속 방법<br>
> 서비스 : 상위계층이 하위계층을 사용하는 방법

* **물리 계층(Physical Layer)**<br>
 -> 인터넷 케이블, 라우터 스위치 등의 전기적 신호가 물리적인 장치에 의해 왔다 갔다(통신) 하는 계층 
 
* **데이터 링크 계층(Data Link Layer)**<br>
 -> 상위의 네트워크 계층에 신뢰성을 보장하기 위해 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하며 오류를 찾고 재전송을 하는 기능이 있는 계층<br>
 -> 프레임(Frame) : 데이터 링크 계층을 이용해 전송되는 데이터
 
* **네트워크 계층(Network Layer)**<br>
 -> 송신 호스트가 전송한 데이터가 어떤 경로를 통해 수신 호스트에 전달되는지를 결정(Static, Dynamic)하는 라우팅 문제를 처리<br>
 -> 패킷(Packet) : 네트워크 계층을 이용해 전송되는 데이터<br>
 -> 트래픽이 과도하게 증가하는 문제를 조절하는 혼잡 제어(Congestion Control) 기능 포함
 
* **전송 계층(Transport Layer)**<br>
 -> 컴퓨터 내부에서 논리적으로 구축되는 통신 당사자인 프로세스 사이의 통신문제를 다루기에 송신 프로세스와 수신 프로세스를 직접 연결하는 단대단(End-to-End) 통신 기능을 제공<br>
 -> 전송 오류율, 전송 속도 등과 같은 일반 사용자의 서비스 요구 유형에 대한 고려와 흐름 제어 기능 제공
 
* **세션 계층(Session Layer)**<br>
 -> 통신 장치 간 상호작용 및 동기화 제공<br>
 -> 연결 세션에서 데이터 교화과 에러 발생 시의 복구를 관리
 
* **표현 계층(Presentation Layer)**<br>
 -> 데이터를 어떻게 표현할지 정하는 계층(코드 간 번역을 담당, text인지 그림인지 gif인지 jpg인지 구분)
 
* **응용 계층(Application Layer)**<br>
 -> 사용자와 가장 밀접한 계층으로 인터페이스 역할<br>
 -> 응용 프로세스 간의 정보 교환을 담당(전자메일, 인터넷, 동영상 플레이어 등)

## TCP(Transmission Control Protocol, 전송 제어 프로토콜)
🚀 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜

[ 특징 ]
 - Connection 연결(3 way handshake) - 양방향 통신
 - 데이터의 순차 전송을 보장
 - Flow Control(흐름제어)
 - Congestion Control(혼잡 제어)
 - Error Detection(오류 감지)
 - UDP보다 속도가 느리다(Time wait 때문)
 - 전이중(Full-Duplex, 양방향 통신), 점대점(Point to Point) 방식

### Segment
🚀 TCP 프로토콜의 PDU(Protocaol Data Unit)
* 데이터를 잘라서 전송하게 되는데, 이때 잘라진 데이터와 TCP Header가 붙어서 하나의 Segment를 구성한다.

### TCP Header
🚀 TCP가 맡은 역할을 수행하고 데이터의 정보를 표현하기 위해 데이터에 붙히는 헤더

* Souce port, Destination port : 포트 번호 정보
* Sequence Number : 전송하는 데이터의 순서 정보(올바른 데이터 재조립에 사용)
* Acknowledgment Number : 승인 번호, 데이터를 받은 수신자가 예상하는 다음 시퀀스 번호
* Data Offset : 전체 Segment 중, 헤더가 아닌 데이터가 시작되는 위치 표시
* Reserved(3 bits) : 미래를 위해 예약된 필드로 모두 0으로 채워져야 함
* Flags : 세그먼트의 속성을 나타내는 9개의 비트 플래그
* Window Size : 한번에 전송할 수 있는 데이터 양
* Checksum : 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값
* Urgent Pointer : 긴급 포인터(URG 플래그가 1이라면 수신 측은 이 포인터가 가리키고 있는 데이터를 우선 처리)
* Options : TCP의 기능을 확장할 떄 사용(크기가 고정된 것이 아니라 가변적)

## TCP 3 way handshake(연결)

![image](https://snabaynetworking.com/wp-content/uploads/2019/10/TCP-3-Way-Handshake-Process-1.jpg)

**[Step 1]**
**Client**가 **Server**에게 연결을 시도하는 SYN 비트를 1로 설정해 패킷 송신

**[Step 2]**
**Server**가 **Client**에게 연결 잘 받았고 나도 연결하려고 ACK, SYN 비트를 1로 설정해 패킷 송신

**[Step 3]**
**Client**가 **Server**에게 연결 잘 받았고 데이터 보내려고 ACK 비트를 1로 설정해 패킷 송신

> 패킷은 택배

## TCP 4 way handshake(연결 해제)

![image](https://t1.daumcdn.net/cfile/tistory/99229C485C1D90C038)

**[Step 1]**
데이터를 전부 송신한 **Client**가 **Server**에게 FIN 송신

**[Step 2]**
**Server**가 **Client**에게 FIN 잘 받았다고 ACK 송신

**[Step 3]**
**Server**가 **Client**에게 남은 패킷 송신 (Client 일정 시간 대기)

**[Step 4]**
**Server**가 **Client**에게 FIN 송신

**[Step 5]**
**Client**가 **Server**에게 FIN 잘 받았다고 ACK 송신

## 흐름제어
🚀 송신측과 수신측 사이의 **데이터 처리 속도 차이(흐름)을 제어**하기 위한 기법으로 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.

* Stop and Wait(정지 - 대기)<br>
 -> 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다. 이러한 구조로 인해 비효율적이라는 단점이 있다.
 
* Sliding Window(슬라이딩 윈도우)<br>
 -> 윈도우 : 송신, 수신, 스테이션 양쪽에서 만들어진 버퍼의 크기<br>
 -> 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다. 따라서 송신측에는 ACK 프레임을 수신하지 않더라도 여러개의 프레임을 연속적으로 전송할 수 있다.<br>
 -> Stop and Wait의 비효율성을 개선했다.
 
## 혼잡제어

🚀 **송신측**의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다.
* 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실이 발생한다.
* 이러한 네트워크 혼잡을 피하기 위해 **송신측**에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어의 개념이다.

### AIMD(Additive Increase Multicative Decrease)

![image](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F6f811337-3638-40cf-a5a8-255dbc07e25c%2F%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C%20(6).png)

* 합 증가/곱 감소 알고리즘이라고 한다.
* 송신 -> 수신에서 문제가 없다면 Window Size를 1씩 증가, 문제가 있다면 패킷을 보내는 속도를 절반으로 감소한다.
* 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다.
* 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식

### Slow Start

![image](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2Feccd9315-2043-4dd1-9fdf-efffa3fac94e%2F%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C%20(7).png)

* AIMD가 네트워크 수용량 주변에서는 효율적으로 동작하지만, 처음에 전송 속도를 올리는데 시간이 너무 길다는 단점이 있다.
* 패킷을 하나씩 보내는데 문제 없이 동장하여 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기를 지나면 Window Size는 2배가 된다.
* 따라서 그래프는 지수함수 꼴이 된다.
* 혼잡 현상이 발생하면 Window Size를 1로 떨어뜨린다.
* 한 번 혼잡 현상이 발생했던 Window Size의 절반까지는 이전처러 ㅁ지수함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.
* 미리 정해진 임계값(Threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
* 임계값에 도달하면 혼잡 회피 단계로 넘어간다.

[혼잡 회피(Congestion Avoidance)]
* WS가 임계값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높다.
> WS : Window Size
* 따라서 이를 회피하기 위해 윈도우 크기를 1씩 증가시킨다.
* 수신측으로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우
 -> 타임 아웃의 발생 : 네트워크 혼잡이 발생했다고 인식<br>
 -> 혼잡 상태로 인식된 경우<br>
   ->> 윈도우의 크기 세그먼트 수를 감소시킨다.<br>
   ->> 동시에 임계값을 패킷 손실이 발생했을 떄의 윈도우 크기의 절반으로 줄인다.
   
[빠른 회복(Fast Recovery)]
* 혼잡한 상태가 되면 WS를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법
* 빠른 회복 정책까지 적용하면 혼잡 상황을 한 번 겪고 나서는 순수한 AIMD 방식으로 동작하게됨

[빠른 재전송(Fast Retransit)]
* 패킷 하나가 손실되어 순번이 중복된 ACK패킷을 받게 되면, 문제가 되는 패킷을 재전송 할 수 있다.
* 중복된 순번의 패킷을 3개 받으면 재전송한다. 
* 이러한 현상이 일어나는 것은 약간의 혼잡이 발생한 것으로 간주하여 WS를 절반으로 줄인다.
   
   

# 운영체제
## 프로세스(Process)
CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행 중인 프로그램을 의미하며, 작업(Job) 또는 태스크(Task)라고도 한다.  
실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.

### 프로세스 상태
![image](https://user-images.githubusercontent.com/44667299/161418773-d365a148-fc64-43dd-8f3d-0eee5391d44e.png)  
|프로세스 상태|설명|
|:---:|---|
|생성(new)(Create)|<ul><li>사용자에 의해 프로세스가 생성된 상태</li></ul>|
|준비(Ready)|<ul><li>CPU를 할당받을 수 있는 상태</li><li>준비 리스트 : 각각 우선순위를 부여하여 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당 받음</li></ul>|
|실행(Running)|<ul><li>프로세스가 CPU를 할당받아 동작 중인 상태</li></ul>|
|대기(Waiting)|<ul><li>프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태</li><li>대기 리스트 : 우선순위가 존재하지 않음</li></ul>|
|완료(Complete)/<br/>종료(Terminated)|<ul><li>프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태</li></ul>|

### 프로세스 상태 전이
|프로세스 상태 전이|설명|
|:---:|---|
|디스패치<br/>(Dispatch)|<ul><li>준비 상태에 있는 여러 프로세스(Ready List) 중 실행될 프로세스를 선정(Scheduling)하여 CPU를 할당(Dispatching) → 문맥교환 발생</li><li>프로세스는 준비 상태에서 실행 상태로 전이</li></ul>|
|할당 시간 초과<br/>(Timeout)|<ul><li>CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비 상태로 전이됨</li><li>프로세스는 실행 상태에서 준비 상태로 전이</li><li>타임 슬라이스(Time Slice) 만료, 선점(Preemption) 시 타임아웃 발생</li></ul>|
|입출력 발생<br/>(Block)|<ul><li>실행 상태에 있는 프로세스가 지정된 할당 시간을 초과하기 전에 입출력이나 기타 사건이 발생(block)하면 CPU를 스스로 반납하고 입출력이 완료될 때 까지 대기 상태로 전이됨</li><li>프로세스는 실행 상태에서 대기 상태로 전이</li><li>즉시 실행 불가능한 시스템 콜, I/O 작업 시작, 프로세스 간 통신 시 Block 발생</li></ul>|
|깨움<br/>(Wake-up)|<ul><li>어느 순간에 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이됨</li><li>프로세스는 대기 상태에서 준비 상태로 전이</li></ul>|
>문맥교환(COntext Switching) : CPU가 현재 실행하고 있는 프로세스의 문맥 상태를 프로세스 제어블록(PCB)에 저장하고 다음 프로세스의 PCB로 부터 문맥을 복원하는 작업을 문맥교환이라고 한다.

### 프로세스 제어 블록(Process Control Block, PCB)
특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료 구조이다.  
프로세스의 상태 정보를 저장하는 자료구조. 운영체제가 프로세스를 표현한 것이라 할 수 있다.  
각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 메인 메모리에 의해 유지되며,  
운영체제에서 한 프로세스의 존재를 정의한다. 프로세스가 완료되면 PCB는 제거된다.  
  
프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어있던 내용을 불러와 이전에 종료됬던 시점부터 다시 작업을 수행한다.
|PCB 구성요소|설명|
|:---:|---|
|프로세스 식별자<br/>(Process ID)|<ul><li>각 프로세스에 대한 고유 식별자</li></ul>|
|프로세스 상태<br/>(Process State)|<ul><li>생성, 준비, 실행, 대기, 중단 등의 상태를 표시</li></ul>|
|프로그램 카운터<br/>(Program Counter)|<ul><li>이 프로세스가 다음에 실행할 명령어의 주소를 가리킴</li></ul>|
|레지스터 저장 영역<br/>(CPU 레지스터)|<ul><li>누산기, 인덱스 레지스터, 범용 레지스터, 조건 코드 등에 관한 정보</li><li>인터럽트가 발생하면 프로그램 카운터와 함께 저장되어 다시 실행될 때 원상 복귀할 수 있게 함</li></ul>|
|프로세스(CPU) 스케줄링 정보|<ul><li>우선순위, 스케줄링 큐에 대한 포인터, 그 외 다른 스케줄 매개변수</li></ul>|
|계정(어카운팅) 정보|<ul><li>프로세서 사용 시간, 실제 사용 시간, 사용 상한 시간, 계정 번호, 작업이나 프로세스 번호 등</li></ul>|
|입출력 상태 정보|<ul><li>입출력 요구 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등</li></ul>|
|메모리 관리 정보|<ul><li>해당 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 정보 등</li></ul>|

## 스레드(Thread)
프로세스 실행의 단위  
동일한 일을 하는 부분이 많은 프로세스를 여러 개 생성하는 것은 메모리 낭비이다. 그래서 프로세스는 하나만 생성하고 Program Counter만 여러 개 생성한다. 즉, CPU 수행 단위를 여러 개를 두는 것이며 이를 스레드라고 한다.
* 스레드는 프로세스보다 가벼운, 독립적으로 수행되는 순차적인 제어의 흐름이며, 실행 단위이다.
* 스레드는 프로세스에서 실행 제어만 분리한 실행 단위로 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.
* 각 스레드별로 자신만의 스택과 레지스터를 가진다.

스레드 종류
|스레드 종류|설명|
|:---:|---|
|사용자 수준의 스레드|<ul><li>사용자가 만든 라이브러리를 사용하여 스레드를 운용</li><li>속도는 빠르지만 구현이 어려움</li><li>라이브러리 차원에서 지원되는 스레드이다. 프로세스 안에 스레드가 여러 개 있다는 것을 OS가 모르기 때문에 커널 입장에서는 하나의 일반적인 프로세스로 인식된다.</li></ul>|
|커널 수준의 스레드|<ul><li>운영체제의 커널에 의해 운용되는 스레드</li><li>구현은 쉽지만 속도가 느림</li><li>프로세스 내 스레드가 여러 개라는 것을 OS가 알고 있는 스레드이다. 그래서 커널이 스레드 스케줄링을 맡아서 하게 된다.</li></ul>|

프로세스와 스레드의 비교  
프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고  
레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
|구분|프로세스(Process)|스레드(Thread)|
|:---:|---|---|
|요소 기술|PCB, 텍스트, 데이터, 힙, 스택|스레드 ID, 레지스터 집합, 스택|
|통신 방법|프로세스 간 통신은 IPC, Pipe, Message, 공유메모리 등을 사용|스레드 간 통신에는 IPC, Pipe, Message뿐 아니라, 전역 변수를 사용할 수 있음|
|시스템 부하|문맥전환을 통해 프로세스 간 전환이 일어나기 때문에 시스템 부하가 큼|경량화된 문맥전환을 사용하여 시스템 부하가 적음|
|활용|운영체제의 기본 구성요소로서, Linux의 경우 Init 프로세스부터 fork하여 시스템을 동작함|Multi Thread를 사용한 서버|
|라이브러리 함수|fork()|pthread_create(), pthread_join()|
* 커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.
* 사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.

### 스택을 스레드마다 독립적으로 할당하는 이유
* 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 가능하게 한다.
* 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

### PC Register 를 스레드마다 독립적으로 할당하는 이유
* PC값은 스레드가 명령어의 어디까지 수행하였는지를 나타내게 된다.
* 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다.
* 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.
* 따라서 PC 레지스터를 독립적으로 할당한다.

## 멀티 스레드
하나의 프로그램(프로세스)을 여러 개의 스레드로 구성하여 작업을 처리하도록 하는 것

### 멀티 스레딩의 장점
* 스레드들은 각자의 stack, 레지스터 영역을 제외한 모든 메모리(ex : 코드/데이터/힙 영역)를 서로 공유하기 때문에 통신의 부담이 적다. → 응답시간 단축
* 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
* 스레드간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소
* 스레드 사이의 작업량이 작아 Context Switching(캐시 메모리를 비울 필요가 없음)이 빠르다.

### 멀티 스레딩의 문제점
* 설계가 빡셈
* 주의 깊은 설계가 필요하다.
* 디버깅이 까다롭다.
* 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
* 다른 프로세스에서 스레드를 제어할 수 없다.(즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.)
* 자원 공유의 문제가 발생한다. 다수의 스레드가 특정 자원을 동시에 사용하는 것을 고려해야 한다. 즉, 동기화 처리가 필요하다.
  * 동기화를 통해 스레드의 작업 처리 순서와 공유 자원에 대한 접근을 제어해야 한다.
  * 일반적으로 락(Lock)을 이용하여 동기화 처리를 하는데, 락이 과도하면 병목 현상이 발생하여 성능 저하를 유발할 수 있다.
* 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다. → 공유하는 메모리를 소유하기 때문

### 멀티 스레드 vs 멀티 프로세스
멀티 스레드  
* 하나의 프로세스 내에 존재하는 다수의 스레드, 메모리 공간(코드, 데이터, 힙)을 공유하지만, 스택, PC 영역은 공유하지 않음
* 오류로 인해 스레드 하나가 종료되면 전체 스레드가 종료될 수 있음 + 동기화 문제

멀티 프로세스
* 독립적인 다수의 프로세스, 메모리 공간(코드, 데이터, 힙, 스택)을 공유하지 않음
* 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 미치지 않음
* 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지함

![image](https://user-images.githubusercontent.com/44667299/161428745-baeb6167-d247-47a7-ae7e-387a8ff6ad4f.png)  
그림출처 : https://goodmilktea.tistory.com/24

## 스케줄러
* 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할
* CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리
* 처리율과 CPU 이용률을 증가시키고 오버헤드, 응답시간, 반환시간, 대기시간을 최소화시키기 위한 기법
* 특정 프로세스가 적합하게 실행되도록 프로세스 스케줄링에 의해 프로세스 사이에서 CPU 교체가 일어남

프로세스를 스케줄링하기 위한 Queue에는 세 가지 종류가 존재한다.
* Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
* Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
* Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

각각의 Queue에 프로세스를 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.
* 스케줄러의 유형에는 장기, 단기, 중기가 있다

프로세스 스케줄링 주요 용어
|용어|설명|
|:---:|---|
|서비스 시간|<ul><li>프로세스가 결과를 산출하기까지 소요되는 시간</li></ul>|
|응답시간<br/>(Response Time)|<ul><li>프로세스들이 입력되어 서비스를 요청하고, 반응하기 시작할 때까지 소요되는 시간</li></ul>|
|반환시간<br/>(Turnaround Time)|<ul><li>프로세스들이 입력되어 수행하고 결과를 산출하기까지 소요되는 시간</li><li>반환시간 = 대기시간 + 수행시간</li></ul>|
|대기시간|<ul><li>프로세스가 프로세서에 할당되기까지 큐에 대기하는 시간</li><li>프로세스가 도착 즉시 프로세서에 할당되면 대기시간 '0'임</li></ul>|
|평균 대기시간|<ul><li>프로세스가 대기 큐에서 대기하는 평균 시간</li><li>대기시간이 '0'인 프로세스도 평균 대기 시간에 합산하여 결과 도출</li></ul>|
|종료 시간|<ul><li>요구되는 Processing time을 모두 수행하고 종료된 시간</li></ul>|
|시간 할당량<br/>(Time Quantum 또는 Time Slice)|<ul><li>한 프로세스가 프로세서를 독점하는 것을 방지하기 위해 서비스되는 시간 할당량</li></ul>|
|응답률|<ul><li>(대기시간 + 서비스시간)/서비스 시간</li><li>HRN(Highest Responce ratio Next) 스케줄링에서 사용</li><li>HRN 스케줄에서 응답률이 높으면 우선순위가 높다 판단</li></ul>|

### 장기스케줄러(Long-term scheduler or job scheduler)
메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue로 보낼지 결졍하는 역할을 한다.
* 메모리와 디스크 사이의 스케줄링을 담당
* 프로세스에 memory(및 각종 리소스)를 할당(admit)
* degree of Multiprogramming 제어 (메모리에 여러 프로그램이 올라가는 것) 몇 개의 프로그램이 올라갈 것인지를 제어
* 프로세스의 상태 : new → ready(in memory)

cf) 메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.

### 단기스케줄러(Short-term scheduler or CPU scheduler)
* CPU와 메모리 사이의 스케줄링을 담당
* Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
* 프로세스에 CPU를 할당(scheduler dispatch)
* 프로세스의 상태 : ready → running → waiting → ready

### 중기스케줄러(Medium-term scheduler or Swapper)
* 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
* 프로세스에게서 memory를 deallocate
* degree of Multiprogramming 제어
* 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러
* 프로세서의 상태 : ready → suspended

## CPU 스케줄러
스케줄링 대상은 Ready Queue에 있는 프로세스들이다.
* 메모리에 있는 준비(Ready)상태의 프로세스 중 하나를 선택 해 CPU의 자원을 할당

### FCFS(First Come First Served)
* 비선점형(Non-Preemptive) 스케줄링 방식
* 먼저 도착한 프로세스가 CPU를 먼저 할당
* 큐를 이용해 쉽게 구현 가능
* 콘보이 현상 발생 가능
>콘보이 현상(Convoy Effect) : burst time이 긴 프로세스가 먼저 도착해 다른 프로세스의 실행 시간이 전부 늦춰져 효율을 떨어뜨리는 현상

### SJF(Shortest - Job - First)
* 비선점형(Non-Preemptive) 스케줄링 방식
* burst time이 짧은 프로세스가 먼저 CPU를 할당
* Starvation 발생 가능
>기아 현상(Starvation) : 계속해서 우선순위가 높은 프로세스(burst time이 짧은)가 먼저 실행되어 먼저 도착했어도 우선순위가 낮은 프로세스(burst time이 긴)가 계속해서 CPU를 할당받지 못하는 현상

### SRTF(Shortest Remaining Time First)
* 선점형(Preemptive) 스케줄링 방식
* 새로운 프로세스가 도착할 때 마다 새로운 스케줄링이 이루어짐
* 남은 burst time이 더 짧은 프로세스에 CPU를 할당
* Starvation 발생 가능
>새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

### Priority Scheduling
* 선점과 비선점 두가지 방식에 모두 적용 가능
  * 선점형(Preemptive) 스케줄링 방식
    * 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.
  * 비선점형(Non-Preemptive) 스케줄링 방식
    * 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣는다.
* 우선순위가 높은 프로세스에 CPU를 먼저 할당
  * 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
* 기아 현상과 무기한 봉쇄가 발생할 수 있으며 에이징 기법을 통해 해결
>무기한 봉쇄(Indefinite blocking) : 실행 준비는 되어 있으나 CPU를 사용못하는 프로세스를 CPU가 무기한 대기하는 상태

>에이징 기법(Aging) : 먼저 도착한 프로세스가 나이를 계속 먹으며 우선순위가 올라가는 기법. 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.

### Round Robin
* 선점형(Preemptive) 스케줄링 방식
* 현대적인 CPU 스케줄링
* 프로세스에 동일한 할당 시간(Time Quantum)만큼 순서대로 계속 CPU를 할당
* 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
* 응답시간이 빠르며, 모든 프로세스가 공정하게 CPU를 할당받을 수 있음을 보장
* CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
* 라운드 로빈이 가능한 이유는 프로세스의 context를 save 할 수 있기 때문이다.
* 단, CPU 할당 시간(Time Quantum)이 길 경우, FCFS랑 같아짐
* 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 overhead가 발생한다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.

## 동기와 비동기 및 Sync와 Async 차이

### 동기(Synchronous)
말 그대로 동시에 일어난다는 뜻. 요청과 그 결과가 동시에 일어난다는 약속인데, 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 함
* 요청한 결과가 한자리에서 동시에 일어남
* A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다.

설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점

### 비동기(Async)
동시에 일어나지 않는다는 의미. 요청과 결과가 동시에 일어나지 않을거라는 약속.
* 요청한 그 자리에서 결과가 주어지지 않음
* 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.

동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점

### Sync vs Async
일반적으로 동기와 비동기의 차이는 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 동기 라고 표현하고 그렇지 않은 경우에 대해서 비동기 라고 표현한다. 동시에라는 말은 실행되었을 때 값이 반환되기 전까지는 blocking 되어 있다는 것을 의미한다. 비동기의 경우, blocking 되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

## 동시성 문제
두 개 이상의 세션이 공통된 자원에 대해서, 모두 읽고 쓰는 작업(Read → Write)을 하려고 하는 경우 발생할 수 있는 문제를 가리킨다.

### Critical Section(임계영역)
멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하는 작업(ex : 공유하는 변수 사용, 동일 파일을 사용 등)을 실행하는 코드 영역  
  
**임계 영역 문제 해결조건**  
* 상호 배제(Mutual Exclusion)
  * 한 스레드가 임계 영역에서 실행 중이면 다른 스레드는 접근 불가능
  * 프로세스 P1이 Critical Section에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section에서 실행될 수 없다.
* 진행(Progress)
  * 임계 영역에서 실행중인 스레드가 없다면, 임계 영역으로 진입하려는 스레드 중 하나는 유한한 시간 내에 진입할 수 있어야 함
  * Critical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.
* 한정된 대기(Bounded Waiting)
  * 임계 영역에 대한 진입 요청 후 만한한 시간을 기다리지 않는 것을 보장
  * P1이 Critical Section에 진입 신청 후 부터 받아들여질 때까지, 다른 프로세스들이 Critical Section에 진입하는 횟수는 제한이 있어야 한다.

### RaceCondition
두 개 이상의 프로세스(스레드)가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황. Race의 뜻 그대로, 간단히 말하면 경쟁하는 상태, 즉 두 개의 스레드가 하나의 자원을 놓고 서로 사용하려고 경쟁하는 상황을 말한다.

### Deadlock(교착상태)
* 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
* 다중프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태
* 세마포가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황

![image](https://user-images.githubusercontent.com/44667299/161562341-74cd9850-4a5e-4ded-84f2-f01aa7eac352.png)
>Semaphores(세마포) : 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구. 공유된 자원의 데이터 혹은 임계영역 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌(즉, 동기화 대상이 하나 이상)

### Deadlock 발생 조건
|발생 조건|설명|
|:---:|---|
|상호배제<br/>(Mutual Exclusive)|<ul><li>프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태</li><li>한 번에 한 프로세스만 공유 자원에 접근 가능하며, 공유 자원에 대한 접근 권한이 제한</li></ul>|
|점유와 대기<br/>(Hold & Wait)|<ul><li>한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태</li><li>공유 자원에 대한 접근 권한을 가지고 있는 프로세스가 다른 자원에 대한 접근 권한을 요구</li></ul>|
|비선점<br/>(Non Preemption)|<ul><li>한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능한 상태</li><li>한 프로세스가 다른 프로세스의 자원을 강제로 빼앗을 수 없음</li></ul>|
|환형 대기<br/>(Circular Wait)|<ul><li>두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태</li></ul>|

### Deadlock 해결 방법
|해결방법|설명|세부기법|
|:---:|---|---|
|예방<br/>(Prevention)|상호배제를 제외한 나머지 교착상태 발생 조건을 위배(부정)하는 방안|점유 자원 해제 후 새 자원 요청|
|회피<br/>(Avoidance)|안전한 상태를 유지할 수 있는 요구만 수락(프로세스별 자원 최대요구량 확보)|은행가 알고리즘, Wound-wait, Wait-Die|
|발견<br/>(Detection)|시스템의 상태를 감시 알고리즘 통해 교착 상태 검사|자원할당 그래프, Wait for Graph|
|복구<br/>(Recovery)|교착상태가 없어질 때까지 프로세스를 순차적으로 Kill하여 제거, 희생자 선택해야하고 기아 상태 발생|프로세스 Kill, 자원선점|

## 메모리 관리 전략
### Paging(페이징)
### Segmentation(세그멘테이션)
## 가상 메모리
### 가상 주소 공간
### 프로세스간의 페이지 공유
### Demand Paging(요구 페이징)
### Page fault trap(페이지 부재 트랩)
## 페이지 교체
### FIFO 페이지 교체
### 최적 페이지 교체(Optimal Page Replacement)
### LRU 페이지 교체(LRU Page Replacement)
### LFU 페이지 교체(LFU Page Replacement)
### MFU 페이지 교체(MFU Page Replacement)
## 기타 
### 동시성과 병령성 차이
### 은행원 알고리즘 

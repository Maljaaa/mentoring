# 운영체제(OS)
## 프로세스(Process)
### 1. 프로그램 vs 프로세스
|프로그램|프로세스|
|:---:|:---:|
|저장장치에 저장되어 있는 정적인 상태|실행을 위해 메모리에 올라온 동적인 상태|
|"짠다", "작성한다"|"실행한다"|
|프로그램 + 프로세스 제어 블록|프로세스 - 프로세스 제어 블록|

> 프로그램 : 컴퓨터에서 실행될 때 특정 작업을 수행하는 일련의 명령어들의 모음(집합)<br>
> 프로세스 : 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램<br>
> 프로세스 제어 블록 : 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조<br>
> 커널 : 운영체제의 주요 구성 요소이며 컴퓨터 하드웨어와 프로세스를 잇는 핵심 인터페이스

### 2. 프로세스 구조
|영역|설명|
|:---:|:---:|
|코드 영역|<ul><li>프로그램의 본문이 기술된 곳으로 텍스트 영역</li></ul><ul><li>읽기 전용</li></ul>|
|데이터 영역|<ul><li>코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳</li></ul><ul><li>읽기/쓰기</li></ul>|
|스택 영역|<ul><li>운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳</li></ul><ul><li>숨김 영역</li></ul>|

### 3. 프로세스 활성 상태(Active Status)

<ul><li>생성 상태</li></ul>

```
생성 상태(Create Status)는 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어블록을 할당받은 상태이다. 
생성된 프로세스는 바로 실행되는 것이 아니라 준비 상태에서 자기 순서를 기다리며, 프로세스 제어 블록도 같이 준비 상태로 옮겨진다.
```

<ul><li>준비 상태</li></ul>

```
준비 상태(Ready Status)는 실행 대기 중인 모든 프로세스가 자기 순서를 기다리는 상태이다. 
프로세스 제어 블록은 준비 큐(Ready Queue)에서 기다리며 CPU 스케줄러에 의해 관리된다. 
CPU 스케줄러는 준비 상태에서 큐를 몇 개 운영할지, 큐에 있는 어떤 프로세스의 프로세스 제어 블록을 실행 상태로 보낼지를 결정한다.
실제로는 다수의 준비 큐가 운영된다.
```

<ul><li>실행 상태</li></ul>

```
실행 상태(Running Status)는 프로세스가 CPU를 할당받아 실행되는 상태이다.
준비 상태에 있는 많은 프로세스 중 실행 상태에 들어가는 프로세스는 CPU의 개수 만큼이다.
실행 상태에 있는 프로세스는 자신에게 주어진 시간, 즉 타임 슬라이스 동안만 작업할 수 있다.
그 시간을 다 사용하면 timeout(PID)가 실행된다.
timeout(PID)는 프로세스 제어 블록을 실행 상태에서 준비 상태로 옮긴다.
만약 실행 상태 동안 작업이 완료되면 exit(PID)가 실행되어 프로세스가 정상 종료된다.
실행 상태에 있는 프로세스가 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)를 실행한다.
block(PID)는 입출력이 완료될 때까지 작업을 진행할 수 없기 때무에 해당 프로세스를 대기 상태로 옮긴다.
CPU 스케줄러는 새로운 프로세스를 실행 상태로 가져온다(dispatch)
```

<ul><li>대기 상태</li></ul>

```
대기 상태(Blocking Status)는 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태로 'wait status'라고도 한다.
대기 상태는 작업의 효율을 위해 만들어진 것으로, 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다린다.
입출력이 완료되면 인터럽트가 발생하고, 대기 상태에 있는 여러 프로세스 중 해당 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)이다.
wakeup(PID)로 해당 프로세스의 프로세스 제어 블록이 준비 상태로 이동하게 된다.
어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은 인터럽트 때문이다.
인터럽트는 입출력으로 발생하지만 어떤 이벤트에 의해 발생하기도 한다.
```

<ul><li>완료 상태</li></ul>

```
완료 상태(Terminate Status)는 프로세스가 종료되는 상태이다.
완료 상태에서는 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다.
정상적인 종료는 간단히 exit()로 처리한다.
만약 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제종료(abort)를 만나면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데,
이를 코어 덤프(core dump)라고 한다.
코어 덤프는 종료 직전의 메모리 상태를 확인함으로써 오류를 수정할 수 있게 해준다.
```

### 4. 프로세스 휴식 상태와 보류 
<ul><li>휴식 상태</li></ul>

```
휴식 상태(Pause Status)는 프로세스가 작업을 일시적으로 쉬고 있는 상태이다.
```

<ul><li>보류 상태</li></ul>

```
보류 상태(Suspend Status)는 프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있다.
보류 상태는 '일시 정지 상태'라고도 불리며, 보류 상태와 비교하여 일반적인 프로세스 상태를 활성 상태라고 한다.
보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역(swap area)에 보관된다.
스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보간되는 곳이다.
보류 상태와 휴식 상태를 구분하자면, 보류 상태는 스왑 영역에 있는 상태에고 휴식 상태는 프로세스가 메모리에 있으나 멈춘 상태이다.
```

### 5. 프로세스의 다섯 가지 상태 정리
<picture>
  <img alt="process 5state" src="https://blog.kakaocdn.net/dn/bf4d6d/btq1NuS4831/dbvf4a9ah1kXaLugrMhrNK/img.png">
</picture>

|상태|설명|작업|
|:---:|:---:|:---:|
|생성 상태|<ul><li>프로그램을 메모리에 가져와 실행 준비가 완료된 상태</li></ul>|메모리 할당, 프로세스 제어 블록 생성|
|준비 상태|<ul><li>실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태</li></ul><ul><li>실행될 프로세스를 CPU 스케줄러가 선택</li></ul>|dispatch(PID) : 준비 -> 실행|
|실행 상태|<ul><li>선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태</li></ul><ul><li>프로세스 사이의 문맥 교환이 일어남</li></ul>|timeout(PID) : 실행 -> 준비<br>exit(PID) : 실행 -> 완료<br>block(PID) : 실행 -> 대기|
|대기 상태|<ul><li>실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태</li></ul><ul><li>입출력이 완료되면 준비 상태로 감</li></ul>|wakeup(PID) : 대기 -> 준비|
|완료 상태|<ul><li>프로세스가 종료된 상태</li></ul><ul><li>사용하던 모든 데이터가 정리됨</li></ul><ul><li>정상 종료인 exit와 비정상 종료인 abort를 포함</li></ul>|메모리삭제, 프로세스 제어 블록 삭제|

### 6. 프로세스 제어 블록(PCB) 

```
프로세스 제어 블록(PCB)은 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조로 TCB(Task Control Block)라고도 한다.
모든 프로세스는 고유의 프로세스 제어 블록을 가지며, 프로세스 제어 블록은 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기된다.
```

### 6-1. 프로세스 제어 블록의 구성
<picture>
  <img src="구성도" src="https://blog.kakaocdn.net/dn/cjrby0/btqIarikobp/wPTdGGKemxiT7XkXXEBdQ0/img.png">
</picture>

|구성 요소|설명|
|:---:|:---:|
|포인터|<ul><li>프로세스 제어 블록의 첫 번째 블록에는 포인터가 저장됨</li></ul><ul><li>준비 상태나 대기 상태는 큐로 운영되는데, 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용</li></ul>|
|프로세스 상태|<ul><li>프로세스가 현재 어떤 상태에 있는지 나타냄</li></ul><ul><li>프로세스 제어 블록의 두 번째 블록에 저장됨</li></ul>|
|프로세스 구분자|<ul><li>운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장</li></ul>|
|프로그램 카운터|<ul><li>다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장</li></ul>|
|프로세스 우선순위|<ul><li>높은 우선순위의 프로세스가 낮은 우선순위의 프로세스보다 먼저 실행되고 더 자주 실행되는데, 그 우선순위를 저장</li></ul>|
|각종 레지스터 정보|<ul><li>프로세스가 실행되는 중에 사용하던 레지스터(누산기, 색인 레지스터, 스택 포인터 등)의 값을 저장</li></ul><ul><li>이전에 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관</li></ul>|
|메모리 관리 정보|<ul><li>메모리 위치 정보(프로세스가 메모리의 어디에 있는지 나타냄), 경계 레지스터 값과 한계 레지스터 값(메모리 보호를 위해 사용) 등을 저장</li></ul><ul><li>세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관</li></ul>|
|할당된 자원 정보|<ul><li>프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보 저장</li></ul>|
|계정 정보|<ul><li>계정 번호, CPU 할당 시간, CPU 사용 시간 등의 정보를 저장</li></ul>|
|부모 프로세스 구분자와 자식 프로세스 구분자|<ul><li>PPID, CPID 정보를 저장</li></ul><ul><li>부모 - 자식 프로세스의 관계는 프로세스를 이해하는데 매우 중요</li></ul>|

> 세그먼테이션 테이블, 페이지 테이블은 뒤에서 다시 다룸

## 스레드(Thread)
### 1. 스레드란?

<picture>
  <img src="스레드" src="[https://blog.kakaocdn.net/dn/cjrby0/btqIarikobp/wPTdGGKemxiT7XkXXEBdQ0/img.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FosRVf%2FbtqHBR7RijE%2Fh37xgA9jZLc31VEw03zMw0%2Fimg.png)">
</picture>

```
프로세스의 코드에 정의 절차에 따라 CPU에 작업 요청을 하는 실행 단위
```

* 특징
  * 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유
  * 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행
  * 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유 / 프로세스는 다른 프로세스의 메모리에 직접 접근 X
  * 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있음
  * 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있음

### 2. 스택을 스레드마다 독립적으로 할당하는 이유

```
스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는것 -> 독립적인 실행 흐름이 추가되는 것
스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소조건으로 독립된 스택을 할당
```

### 3. PC Register를 스레드마다 독립적으로 할당하는 이유

```
스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당함
명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있음
따라서 PC Register를 독립적으로 할당
```

## 멀티 스레드
### 1. 헷갈리기 쉬운 스레드 관련 용어 정리
|스레드 용어|설명|
|:---:|:---:|
|멀티스레드|<ul><li>운영체제가 소프트웨어적으로 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법</li></ul>|
|멀티태스킹|<ul><li>운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법</li></ul><ul><li>여러 스레드에 시간을 잘게 나누어주는 시스템을 시분할 시스템(time-sharing system)이고 CPU에 전달하는 작업은 스레드</li></ul>|
|멀티프로세싱|<ul><li>하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(Task)을 처리하도록 하는 것</li></ul><ul><li>CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경</li></ul><ul><li>하나의 컴퓨터에 여러 개의 CPU, 하나의 CPU 내 여러 개의 코어에 스레드 배정, 네트워크로 연결된 여러 컴퓨터에 스레드를 나누어 협업하는 분산시스템 => 멀티프로세싱</li></ul>|
|CPU 멀티스레드|<ul><li>하드웨어적인 방법으로 하나의 CPU에서 여러 스레드를 동시에 처리하는 병렬 처리 기법</li></ul>|

### 2. 멀티 스레딩의 장점

```
프로세스는 크게 정적인 영역과 동적인 영역으로 구분된다. 
여러 개의 프로세스를 만들면 필요없는 정적 영역이 여러 개가 된다. 
이 문제를 해결하기 위해 하나의 프로세스 내에 여러 개의 스레드를 생성하는 멀티스레드는 
코드, 파일 등의 자원을 공유함으로써 자원의 낭비를 막고 효율성을 향상한다.
```

<picture>
  <img src="멀티스레드" src="https://jaeseongdev.github.io/assets/img/posts/development-os/2021-06-16-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%2C%20%EB%A9%80%ED%8B%B0%EC%93%B0%EB%A0%88%EB%93%9C%20%3A%20%20%EB%A9%80%ED%8B%B0%20%ED%83%9C%EC%8A%A4%ED%82%B9%20%3A%20%EB%A9%80%ED%8B%B0%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1%20%3A%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98%20%EC%B0%A8%EC%9D%B4/Untitled.png">
</picture>

|멀티 스레딩의 장점|설명|
|:---:|:---:|
|응답성 향상|<ul><li>한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있음</li></ul>|
|자원 공유|<ul><li>한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있음</li></ul>|
|효율성 향상|<ul><li>여러 개의 프로세스를 생성하는 것과 달리 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상됨</li></ul>|
|다중 CPU 지원|<ul><li>2개 이상의 CPU를 가진 컴퓨터에서 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축됨</li></ul>|

### 3. 멀티스레딩의 문제점
* 주의 깊은 설계가 필요함
* 디버깅이 까다로움
* 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
* 다른 프로세스에서 스레드를 제어할 수 없음(즉, 프로세스 밖에서 스레드 각각을 제어할 수 없음)
* 멀티 스레드의 경우 자원 공유의 문제가 발생(동기화 문제)
* 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

> 이해하기 쉬운 예 : 인터넷 익스플로어(멀티 스레드) vs 크롬(멀티 태스킹)
> 
> 인터넷 익스플로어는 하나의 탭이 문제 생기면 익스플로어 자체가 종료됨
> 
> 크롬은 하나의 탭이 문제 생겨도 문제 있는 탭만 종료할 수 있음
> 
### 4. 멀티 프로세스의 장점
* 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽은 것 이상으로 다른 영향이 확산되지 않음

### 5. 멀티 프로세스의 문제점
|멀티 프로세스의 문제점|설명|
|:---:|:---:|
|Context Switching(문맥 교환)에서의 오버헤드|<ul><li>Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됨</li></ul><ul><li>프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching이 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 함</li></ul>|
|프로세스 사이의 어렵고 복잡한 통신 기법(IPC)|<ul><li>프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 포르세스들 사이의 변수를 공유할 수 없음</li></ul>|

### 6. 멀티 스레드 vs 멀티 프로세스
|멀티 스레드|멀티 프로세스|
|:---:|:---:|
|적은 메모리 공간 차지 -> Context Switching 빠름|비교적 많은 메모리 공간 차지 -> Context Switching 느림|
|하나의 스레드 장애로 전체 스레드가 종료될 위험|하나의 스레드 장애로 전체 스레드가 종료될 위험 X|

* 멀티 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠가며 하는 이유
  * 운영체제가 시스템 자원을 효율적으로 관리하기 위해 스레드를 사용
  * 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
  * 프로세스 간의 통신보다 스레드 간의 통신 비용이 적기 때문에 작업들 간 통신의 부단이 줄어듬(프로세스는 독립구조 -> 처리비용 감소)

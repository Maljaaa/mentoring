우선, 동기와 비동기가 무엇일까?

**동기**는 요청에 의한 응답이 올때까지 기다리며
**비동기**는 요청을 보내고 다른 작업을 하다가 응답을 받을 수 있다.

동기와 비동기는 이러한 차이가 있다.

# 동시성 문제

<aside>
💡 동시성 문제란, 두 개 의상의 세션이 공통된 자언에 대해 모두 읽고 쓰는 작업 (Read → Write)를 할 때 발생하는 문제를 뜻한다.

</aside>

## Critical Section

임계구역이라 하는 Critical Section은 한 번에 하나의 프로세스만 액세스 할 수 있는코드 영역을 의미한다.

프로세스는 일반적으로 4가지의 코드 영역으로 나뉜다.

- Entry Section
    - Critical Section에 진입하기 위해 진입허가 요청을 하는 영역이다.
    - Critical Section에 진입하는것을 제어한다 하는데 이를 Lock한다고 한다.
- Ciritical Section
    - 하나의 프로세스 만 접근할 수 있는 영역이다.
- Exit Section
    - Lock을 해제하는 등, 더이상 Critical Section에 존재하지 않을 때 알리는 역할을 한다.
- Reminder Section
    - 입력 섹션, 중요 섹션 및 종료 섹션을 제외한 코드의 다른 부분을 나머지 섹션이라고 한다.

Critical Section(임계 구역)에는 둘 이상의 프로세스가 동시에 접근을 할 수 없다. 각 프로세스별로 자신의 임계구역에 들어가기 위해서는 Entry Section에서 진입 허가를 받고 접근을 해야한다.

만약, 여러 프로세스가 동시에 임계구역에 접근을 하려고 한다면 Race Condition이 발생을 한다.

## RaceCondition

<aside>
💡 여러 프로세스가 동시에 공유 데이터에 접근을 할 때 실행 순서에 따라서 결과값이 달라지는것을 의미한다.

</aside>

t1 스레드와 t2 스레드가 있다고 해보자.
공유 데이터로 money가 있을 때 t1이 조회,수정,저장을 진행하고 t2가 조회,수정,저장을 진행하면 문제없이 money의 값이 수정이 될것이다.
하지만, 갑자기 t1과 t2가 한번에 공유 데이터를 접근한다면? 공유 데이터로는 100만원이라는 돈이 있고, t1은 80만원, t2는 50만원을 출금하려 한다. 그런데 동시에 조회,수정,저장을 했더니 돈이 부족하여 출금이되면 안되는데 두번 다 출금이 되버렸다.. 이렇다면 큰 문제가 발생하는것이다

이런 에러의 발생이 바로 RaceCondition이다.

### 해결방법

`Semaphore(세마포어)`와  `Mutual Exclusion(Mutex, 상호배재)` 로 2개의 해결방법으로 나뉜다. 이 두 해결방법은 **메커니즘과 동기화 대상의 차이**이다.

- Semaphore(Signaling, 세마포어)
    - 락을 걸지않은 프로세스 혹은 스레드도 Signal을 보내 Lock을 해제할 수 있다.
    - 시그널을 통해서 프로세스 혹은 스레드의 Lock을 잠그고 풀 수 있다.
- Mutex(Locking, 뮤텍스)
    - 하나의 프로세스 혹은 스레드만이 Lock을 걸고 풀 수 있다.

## Deadlock

Deadlock은 교착상태이다.

이러한 교착상태가 일어나기 위해서는 아래 네 가지 조건이 필요하다.

1. 상호배재(Mutual Exclusion)
2. 점유대기(Hold and Wait)
3. 비선점(No Preemption)
4. 순환대기(Circular Wait)

이 조건들을 보니 어디서 본 조건이 있다. 바로 Mutual Exclusion(Mutex), 상호배재 이다. Race Condition에서 이를 사용할 때 위의 조건이 있다면 Semaphore방법을 이용하는것이 좋다.

<aside>
💡 테슬라와 아우디가 골목길에서 서로 만났다. 둘 중 하나는 후진을 해야 골목길을 나갈 수 있지만, 서로 후진을 하지 않고 클락션만 울리고있는 상태이다.

</aside>

## Deadlock 해결방법

해결 방법에는 `교착 상태 예방, 회피, 무시, 발견` 이렇게 총 4가지로 나뉘게 된다.

이렇게 총 4가지로 나뉘는데 위에서부터 차근차근 알아보도록 하자.

### 교착 상태 예방

- 상호 배제 조건의 제거
    - 교착 상태는 서로 같은 공유자원을 접근할 때 발생하는 오류이다.
    - 즉, 상호 배제 조건을 제거하면 교착상태를 예방할 수 있다.
- 점유와 대기 조건의 제거
    - 한 프로세스가 수행되기 전 모든 자원을 할당시키고, 이 후 자원이 할당되지 않을 때 다른 프로세스가 요청할 수 있게끔 하는 방법이다.
    - 이는 자원의 효율성 문제와 자원파악 비용, 자원 저장 및 복원 비용, 기아상태, 무한대기 등의 문제점이 있다.
- 비선점 조건 제거
    - 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.
- 환형 대기 조건의 제거
    - 자원 유형에 따라 순서를 매긴다

### 교착 상태의 회피

자원이 어떻게 요청이 될 지 추가정보를 제공하도록 요구하는 것으로, 시스템에 Circle Wait이 발생하지 않도록 자원 할당 상태를 검사하는것이다.

방법에는 크게 두가지가 있다.

1. 자원 할당 그래프 알고리즘
2. 은행원 알고리즘

### 교착 상태의 무시

예방 혹은 회피기법을 프로그래밍해서 넣으면 성능에 큰 영향을 미칠 수 있기 때문에, 데드락의 발생 확률이 낮을경우 별 다른 조치를 취하지 않는다.

### 교착 상태의 발견

감시/발견을 하는 Detection알고리즘으로, Deadlock 발생을 체크하는 방식. 이 역시 성능에는 큰 영향을 미친다.

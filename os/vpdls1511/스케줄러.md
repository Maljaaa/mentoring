프로세스를 스케줄링 하기 위해서 사용하는 Queue는 3가지가 존재한다.
그런데, 이를 알기 전 왜 스케줄링을 해야할까?

이전 글에 PCB에 관해서 정리를 한 내용이 있는데 이를보면 PCB에 존재하는 다양한 정보 중 한 가지, 바로 프로세스의 상태를 알려주는 정보가 있다.

<aside>
💡 CPU를 점유중인 한 프로세스가 입출력 요청에 의해 Wait으로 변경이 되었다. 그런데 해당 정보가 Wait에서 Ready 상태로 돌아올 때 까지 계속 기다리고만 있는다면 이는 얼마나 비효율적인가?

</aside>

스케줄링이 필요한 이유는, 이러한 비효율적인 과정을 줄이기 위함이며, 이러한 스케줄링은 다중 프로그램을 지원하는 운영체제에서는 정말 중요하며, 필수적인 요소이다.

다시 본론으로 돌아와서 스케줄링에서 사용하는 Queue는 3가지가 존재한다고 맨 처음에 언급하였다.

- Job Queue : 현재 시스템 내에 있는 모든 프로세스들의 집합
- Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

이렇게 총 3개의 Queue가 존재하는데, 이러한 Queue에 따라서 스케줄러의 종류에도 크게 3가지로 나뉘게 된다.

![Untitled](https://media.vlpt.us/images/vpdls1511/post/d43384d4-ded4-49ca-9aa2-ef24974d49ef/Untitled.png)

# 장기 스케줄러

장기 스케줄러는 Long-term Scheduler 이지만, Job Scheduler 라고 한다.
이는 무엇일까?

이 장기 스케줄러는 어떤 프로세스를 준비 큐에 삽입할 지 결정하는 역할을 한다.
이게 무슨소리인가 싶을것이다.

<aside>
💡 디스크에서 하나의 프로그램을 가져온다. 이를 사용하기 위해서는 커널에 등록을 해야 프로세스가 되는데, 이 때 디스크에서 어떤 프로그램을 가져와 커털에 등록할 지 결정을 해주는 역할을 하는 스케줄러 이다.

</aside>

그런데 이는 왜 필요한것일까?

한 가지 예시를 들어보자.

<aside>
💡  내가 수행을 해야하는 Job은 50개라고 하자. 그런데, 메모리에는 최대 30개밖에 올릴 수 없는 상황이다.
이럴 때 어떻게 해야할까? 이 때 우리는 어떤것을 메모리에 올릴지 고민을 하게되는데, 이 스케줄러는 이러한 역할을 해준다. 
 여기서 먼저 적재시킬 프로그램을 선정하는 과정에서는 CPU Bound 인지 I/O Bound 인지 구분하여 적절히 Queue에 올려주는 역할을 하게된다.

</aside>

즉, 한계치를 넘는 작업을 수행해야 할 때 이 스케줄러가 우선순위를 정해주어 더욱 효율적으로 작업을 진행할 수 있도록 도와주게 된다.

`하.지.만. 요즘에는 장기 스케줄러는 없다고 한다.`
왜 그럴까?

이유는, 가상메모리(Virtual Memory Management)의 발달로 인해 없어졌다고 한다.
물리적인 메모리에는 한계가 있지만, 가상의 메모리에는 제한이 없는것 처럼(실제로 무한은 아니다) 운영체제가 서비스를 해주기 때문에 50개중 30개가 아닌 50개를 다 올려버린다.

# 단기 스케줄러

단기 스케줄러는 CPU 스케줄러 라고도 한다. 왜 이렇게 불리울까?

<aside>
💡 이는 어떤 프로세스를 다음 번에 실행 상태로 만들것인지를 결정하는 스케줄러 이다.
일반적으로 우리가 “스케줄러!” 라고 하면 단기 스케줄러를 의미하는 경우가 많으며, 이 스케줄러는 스케줄러 알고리즘에 따라서 CPU에 어떤 프로세스를 할당할 지 선택을 하게 된다.

</aside>

위에 언급한 스케줄링 알고리즘에는 크게 두 가지가 있다.

- 선점 스케줄링
    - 우선순위가 높은 프로세스가 긴급 처리되어야 할 때 유용하며, 모든 프로세스를 프로세서에 할당할 수 있는 기회가 생긴다.
    - 하지만, 잦은 컨텍스트 스위칭으로 인하여 오버헤드가 높다.
- 비선점 스케줄링
    - 실행시간이 짧은 프로세스가 먼저 자원을 가질 수 있어 평균 대기시간이 짧다.
    - 하지만, 긴 프로세스는 짧은 프로세스에게 밀려 프로세스가 기아상태에 빠질 수 있다.

# 중기 스케줄러

이는 메모리에 적재된 프로세스를 관리해주는 스케줄러 이다.

이 중기 스케줄러에는 4가지의 개념이 등장한다.

- Swaping
- Trashing
- Swap Out
- Swap In

## Swaping

장기 스케줄러와 마찬가지로, 메모리에 올라와있는 프로세스의 수를 조절하는것.

trashing, swap out, swap in 이들을 전체적으로 Swaping이라고 한다.

## Trashing

여러개의 프로세스가 작동을 하고 있고, 이 프로세스들에게 메모리가 모두 할당이 되면 CPU 수행에 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상황이 생기는데, 이렇게 되면 디스크 I/O가 수시로 발생하여 시스템의 성능이 심각하게 저하가 된다.

이 때 생기는 개념이 Trashing인데 , 가상메모리 체계에서 너무 많은 프로스세스가 적재되면 하드디스크 입출력이 과다해져서 시스템이 거의 멈추는 현상을 Trashing이라고 한다.

## Swap Out

Trashing이 발생했을 때 프로세스중 일부의 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 적재를 해 놓는다. 이 행위를 Swap Out 이라고 한다.

이 때, 디스크로 Swap Out 시킬 프로세스는 봉쇄 상태(중단 상태)에 있는 프로세스부터 아웃 시킨다. 이 후에도 문제가 해결되지 않으면 타이머 언터럽트가 발생되어 준비큐로 프로세스를 이동하는 Swap Out을 진행한다.

## Swap In

Swap Out이 생긴 뒤 메모리에 여유가 생기면 Swap Out된 메모리를 다시 적재(Swap In)한다.
